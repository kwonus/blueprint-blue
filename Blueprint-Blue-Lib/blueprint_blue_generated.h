// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BLUEPRINTBLUE_XBLUEPRINTBLUE_H_
#define FLATBUFFERS_GENERATED_BLUEPRINTBLUE_XBLUEPRINTBLUE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace XBlueprintBlue {

struct XBlueprint;
struct XBlueprintBuilder;

struct XCommand;
struct XCommandBuilder;

struct XReply;
struct XReplyBuilder;

struct XStatement;
struct XStatementBuilder;

struct XSearch;
struct XSearchBuilder;

struct XFragment;
struct XFragmentBuilder;

struct XOption;
struct XOptionBuilder;

struct XFeature;
struct XFeatureBuilder;

struct XLex;
struct XLexBuilder;

struct XWord;
struct XWordBuilder;

struct XLemma;
struct XLemmaBuilder;

struct XPOS32;
struct XPOS32Builder;

struct XPOS16;
struct XPOS16Builder;

struct XPunctuation;
struct XPunctuationBuilder;

struct XTransition;
struct XTransitionBuilder;

struct XStrongs;
struct XStrongsBuilder;

struct XDelta;
struct XDeltaBuilder;

struct XSettings;
struct XSettingsBuilder;

struct XScope;
struct XScopeBuilder;

enum XThreshold : int8_t {
  XThreshold_NONE = 0,
  XThreshold_FUZZY_MIN = 33,
  XThreshold_FUZZY_MAX = 99,
  XThreshold_EXACT = 100,
  XThreshold_MIN = XThreshold_NONE,
  XThreshold_MAX = XThreshold_EXACT
};

inline const XThreshold (&EnumValuesXThreshold())[4] {
  static const XThreshold values[] = {
    XThreshold_NONE,
    XThreshold_FUZZY_MIN,
    XThreshold_FUZZY_MAX,
    XThreshold_EXACT
  };
  return values;
}

inline const char *EnumNameXThreshold(XThreshold e) {
  switch (e) {
    case XThreshold_NONE: return "NONE";
    case XThreshold_FUZZY_MIN: return "FUZZY_MIN";
    case XThreshold_FUZZY_MAX: return "FUZZY_MAX";
    case XThreshold_EXACT: return "EXACT";
    default: return "";
  }
}

enum XOutEnum : int8_t {
  XOutEnum_AV = 1,
  XOutEnum_AVX = 2,
  XOutEnum_MIN = XOutEnum_AV,
  XOutEnum_MAX = XOutEnum_AVX
};

inline const XOutEnum (&EnumValuesXOutEnum())[2] {
  static const XOutEnum values[] = {
    XOutEnum_AV,
    XOutEnum_AVX
  };
  return values;
}

inline const char * const *EnumNamesXOutEnum() {
  static const char * const names[3] = {
    "AV",
    "AVX",
    nullptr
  };
  return names;
}

inline const char *EnumNameXOutEnum(XOutEnum e) {
  if (::flatbuffers::IsOutRange(e, XOutEnum_AV, XOutEnum_AVX)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(XOutEnum_AV);
  return EnumNamesXOutEnum()[index];
}

enum XLexEnum : int8_t {
  XLexEnum_AV = 1,
  XLexEnum_AVX = 2,
  XLexEnum_BOTH = 3,
  XLexEnum_MIN = XLexEnum_AV,
  XLexEnum_MAX = XLexEnum_BOTH
};

inline const XLexEnum (&EnumValuesXLexEnum())[3] {
  static const XLexEnum values[] = {
    XLexEnum_AV,
    XLexEnum_AVX,
    XLexEnum_BOTH
  };
  return values;
}

inline const char * const *EnumNamesXLexEnum() {
  static const char * const names[4] = {
    "AV",
    "AVX",
    "BOTH",
    nullptr
  };
  return names;
}

inline const char *EnumNameXLexEnum(XLexEnum e) {
  if (::flatbuffers::IsOutRange(e, XLexEnum_AV, XLexEnum_BOTH)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(XLexEnum_AV);
  return EnumNamesXLexEnum()[index];
}

enum XFmtEnum : int8_t {
  XFmtEnum_JSON = 0,
  XFmtEnum_TEXT = 1,
  XFmtEnum_HTML = 2,
  XFmtEnum_MD = 3,
  XFmtEnum_MIN = XFmtEnum_JSON,
  XFmtEnum_MAX = XFmtEnum_MD
};

inline const XFmtEnum (&EnumValuesXFmtEnum())[4] {
  static const XFmtEnum values[] = {
    XFmtEnum_JSON,
    XFmtEnum_TEXT,
    XFmtEnum_HTML,
    XFmtEnum_MD
  };
  return values;
}

inline const char * const *EnumNamesXFmtEnum() {
  static const char * const names[5] = {
    "JSON",
    "TEXT",
    "HTML",
    "MD",
    nullptr
  };
  return names;
}

inline const char *EnumNameXFmtEnum(XFmtEnum e) {
  if (::flatbuffers::IsOutRange(e, XFmtEnum_JSON, XFmtEnum_MD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXFmtEnum()[index];
}

enum XLangEnum : int8_t {
  XLangEnum_X = 0,
  XLangEnum_H = 1,
  XLangEnum_G = 2,
  XLangEnum_MIN = XLangEnum_X,
  XLangEnum_MAX = XLangEnum_G
};

inline const XLangEnum (&EnumValuesXLangEnum())[3] {
  static const XLangEnum values[] = {
    XLangEnum_X,
    XLangEnum_H,
    XLangEnum_G
  };
  return values;
}

inline const char * const *EnumNamesXLangEnum() {
  static const char * const names[4] = {
    "X",
    "H",
    "G",
    nullptr
  };
  return names;
}

inline const char *EnumNameXLangEnum(XLangEnum e) {
  if (::flatbuffers::IsOutRange(e, XLangEnum_X, XLangEnum_G)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXLangEnum()[index];
}

enum XStatusEnum : int8_t {
  XStatusEnum_ERROR = -128,
  XStatusEnum_OKAY = 0,
  XStatusEnum_MIN = XStatusEnum_ERROR,
  XStatusEnum_MAX = XStatusEnum_OKAY
};

inline const XStatusEnum (&EnumValuesXStatusEnum())[2] {
  static const XStatusEnum values[] = {
    XStatusEnum_ERROR,
    XStatusEnum_OKAY
  };
  return values;
}

inline const char *EnumNameXStatusEnum(XStatusEnum e) {
  switch (e) {
    case XStatusEnum_ERROR: return "ERROR";
    case XStatusEnum_OKAY: return "OKAY";
    default: return "";
  }
}

enum XCompare : uint8_t {
  XCompare_NONE = 0,
  XCompare_text = 1,
  XCompare_lemma = 2,
  XCompare_pos16 = 3,
  XCompare_pos32 = 4,
  XCompare_punctuation = 5,
  XCompare_transition = 6,
  XCompare_strongs = 7,
  XCompare_delta = 8,
  XCompare_MIN = XCompare_NONE,
  XCompare_MAX = XCompare_delta
};

inline const XCompare (&EnumValuesXCompare())[9] {
  static const XCompare values[] = {
    XCompare_NONE,
    XCompare_text,
    XCompare_lemma,
    XCompare_pos16,
    XCompare_pos32,
    XCompare_punctuation,
    XCompare_transition,
    XCompare_strongs,
    XCompare_delta
  };
  return values;
}

inline const char * const *EnumNamesXCompare() {
  static const char * const names[10] = {
    "NONE",
    "text",
    "lemma",
    "pos16",
    "pos32",
    "punctuation",
    "transition",
    "strongs",
    "delta",
    nullptr
  };
  return names;
}

inline const char *EnumNameXCompare(XCompare e) {
  if (::flatbuffers::IsOutRange(e, XCompare_NONE, XCompare_delta)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXCompare()[index];
}

template<typename T> struct XCompareTraits {
  static const XCompare enum_value = XCompare_NONE;
};

template<> struct XCompareTraits<XBlueprintBlue::XWord> {
  static const XCompare enum_value = XCompare_text;
};

template<> struct XCompareTraits<XBlueprintBlue::XLemma> {
  static const XCompare enum_value = XCompare_lemma;
};

template<> struct XCompareTraits<XBlueprintBlue::XPOS16> {
  static const XCompare enum_value = XCompare_pos16;
};

template<> struct XCompareTraits<XBlueprintBlue::XPOS32> {
  static const XCompare enum_value = XCompare_pos32;
};

template<> struct XCompareTraits<XBlueprintBlue::XPunctuation> {
  static const XCompare enum_value = XCompare_punctuation;
};

template<> struct XCompareTraits<XBlueprintBlue::XTransition> {
  static const XCompare enum_value = XCompare_transition;
};

template<> struct XCompareTraits<XBlueprintBlue::XStrongs> {
  static const XCompare enum_value = XCompare_strongs;
};

template<> struct XCompareTraits<XBlueprintBlue::XDelta> {
  static const XCompare enum_value = XCompare_delta;
};

bool VerifyXCompare(::flatbuffers::Verifier &verifier, const void *obj, XCompare type);
bool VerifyXCompareVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct XBlueprint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XBlueprintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_SETTINGS = 6,
    VT_SEARCH = 8,
    VT_SCOPE = 10,
    VT_SINGLETON = 12,
    VT_STATUS = 14,
    VT_HELP = 16,
    VT_WARNINGS = 18,
    VT_ERRORS = 20
  };
  const ::flatbuffers::String *command() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  const XBlueprintBlue::XSettings *settings() const {
    return GetPointer<const XBlueprintBlue::XSettings *>(VT_SETTINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XSearch>> *search() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XSearch>> *>(VT_SEARCH);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XScope>> *scope() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XScope>> *>(VT_SCOPE);
  }
  const XBlueprintBlue::XCommand *singleton() const {
    return GetPointer<const XBlueprintBlue::XCommand *>(VT_SINGLETON);
  }
  XBlueprintBlue::XStatusEnum status() const {
    return static_cast<XBlueprintBlue::XStatusEnum>(GetField<int8_t>(VT_STATUS, -128));
  }
  const ::flatbuffers::String *help() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HELP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *warnings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_WARNINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *errors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ERRORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           VerifyOffsetRequired(verifier, VT_SETTINGS) &&
           verifier.VerifyTable(settings()) &&
           VerifyOffset(verifier, VT_SEARCH) &&
           verifier.VerifyVector(search()) &&
           verifier.VerifyVectorOfTables(search()) &&
           VerifyOffset(verifier, VT_SCOPE) &&
           verifier.VerifyVector(scope()) &&
           verifier.VerifyVectorOfTables(scope()) &&
           VerifyOffset(verifier, VT_SINGLETON) &&
           verifier.VerifyTable(singleton()) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffsetRequired(verifier, VT_HELP) &&
           verifier.VerifyString(help()) &&
           VerifyOffset(verifier, VT_WARNINGS) &&
           verifier.VerifyVector(warnings()) &&
           verifier.VerifyVectorOfStrings(warnings()) &&
           VerifyOffset(verifier, VT_ERRORS) &&
           verifier.VerifyVector(errors()) &&
           verifier.VerifyVectorOfStrings(errors()) &&
           verifier.EndTable();
  }
};

struct XBlueprintBuilder {
  typedef XBlueprint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command(::flatbuffers::Offset<::flatbuffers::String> command) {
    fbb_.AddOffset(XBlueprint::VT_COMMAND, command);
  }
  void add_settings(::flatbuffers::Offset<XBlueprintBlue::XSettings> settings) {
    fbb_.AddOffset(XBlueprint::VT_SETTINGS, settings);
  }
  void add_search(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XSearch>>> search) {
    fbb_.AddOffset(XBlueprint::VT_SEARCH, search);
  }
  void add_scope(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XScope>>> scope) {
    fbb_.AddOffset(XBlueprint::VT_SCOPE, scope);
  }
  void add_singleton(::flatbuffers::Offset<XBlueprintBlue::XCommand> singleton) {
    fbb_.AddOffset(XBlueprint::VT_SINGLETON, singleton);
  }
  void add_status(XBlueprintBlue::XStatusEnum status) {
    fbb_.AddElement<int8_t>(XBlueprint::VT_STATUS, static_cast<int8_t>(status), -128);
  }
  void add_help(::flatbuffers::Offset<::flatbuffers::String> help) {
    fbb_.AddOffset(XBlueprint::VT_HELP, help);
  }
  void add_warnings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> warnings) {
    fbb_.AddOffset(XBlueprint::VT_WARNINGS, warnings);
  }
  void add_errors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> errors) {
    fbb_.AddOffset(XBlueprint::VT_ERRORS, errors);
  }
  explicit XBlueprintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XBlueprint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XBlueprint>(end);
    fbb_.Required(o, XBlueprint::VT_COMMAND);
    fbb_.Required(o, XBlueprint::VT_SETTINGS);
    fbb_.Required(o, XBlueprint::VT_HELP);
    return o;
  }
};

inline ::flatbuffers::Offset<XBlueprint> CreateXBlueprint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> command = 0,
    ::flatbuffers::Offset<XBlueprintBlue::XSettings> settings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XSearch>>> search = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XScope>>> scope = 0,
    ::flatbuffers::Offset<XBlueprintBlue::XCommand> singleton = 0,
    XBlueprintBlue::XStatusEnum status = XBlueprintBlue::XStatusEnum_ERROR,
    ::flatbuffers::Offset<::flatbuffers::String> help = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> warnings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> errors = 0) {
  XBlueprintBuilder builder_(_fbb);
  builder_.add_errors(errors);
  builder_.add_warnings(warnings);
  builder_.add_help(help);
  builder_.add_singleton(singleton);
  builder_.add_scope(scope);
  builder_.add_search(search);
  builder_.add_settings(settings);
  builder_.add_command(command);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XBlueprint> CreateXBlueprintDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *command = nullptr,
    ::flatbuffers::Offset<XBlueprintBlue::XSettings> settings = 0,
    const std::vector<::flatbuffers::Offset<XBlueprintBlue::XSearch>> *search = nullptr,
    const std::vector<::flatbuffers::Offset<XBlueprintBlue::XScope>> *scope = nullptr,
    ::flatbuffers::Offset<XBlueprintBlue::XCommand> singleton = 0,
    XBlueprintBlue::XStatusEnum status = XBlueprintBlue::XStatusEnum_ERROR,
    const char *help = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *warnings = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *errors = nullptr) {
  auto command__ = command ? _fbb.CreateString(command) : 0;
  auto search__ = search ? _fbb.CreateVector<::flatbuffers::Offset<XBlueprintBlue::XSearch>>(*search) : 0;
  auto scope__ = scope ? _fbb.CreateVector<::flatbuffers::Offset<XBlueprintBlue::XScope>>(*scope) : 0;
  auto help__ = help ? _fbb.CreateString(help) : 0;
  auto warnings__ = warnings ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*warnings) : 0;
  auto errors__ = errors ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*errors) : 0;
  return XBlueprintBlue::CreateXBlueprint(
      _fbb,
      command__,
      settings,
      search__,
      scope__,
      singleton,
      status,
      help__,
      warnings__,
      errors__);
}

struct XCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_VERB = 6,
    VT_ARGUMENTS = 8,
    VT_REPLY = 10
  };
  const ::flatbuffers::String *command() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  const ::flatbuffers::String *verb() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERB);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *arguments() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ARGUMENTS);
  }
  const XBlueprintBlue::XReply *reply() const {
    return GetPointer<const XBlueprintBlue::XReply *>(VT_REPLY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           VerifyOffsetRequired(verifier, VT_VERB) &&
           verifier.VerifyString(verb()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfStrings(arguments()) &&
           VerifyOffset(verifier, VT_REPLY) &&
           verifier.VerifyTable(reply()) &&
           verifier.EndTable();
  }
};

struct XCommandBuilder {
  typedef XCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command(::flatbuffers::Offset<::flatbuffers::String> command) {
    fbb_.AddOffset(XCommand::VT_COMMAND, command);
  }
  void add_verb(::flatbuffers::Offset<::flatbuffers::String> verb) {
    fbb_.AddOffset(XCommand::VT_VERB, verb);
  }
  void add_arguments(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> arguments) {
    fbb_.AddOffset(XCommand::VT_ARGUMENTS, arguments);
  }
  void add_reply(::flatbuffers::Offset<XBlueprintBlue::XReply> reply) {
    fbb_.AddOffset(XCommand::VT_REPLY, reply);
  }
  explicit XCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XCommand>(end);
    fbb_.Required(o, XCommand::VT_COMMAND);
    fbb_.Required(o, XCommand::VT_VERB);
    return o;
  }
};

inline ::flatbuffers::Offset<XCommand> CreateXCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> command = 0,
    ::flatbuffers::Offset<::flatbuffers::String> verb = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> arguments = 0,
    ::flatbuffers::Offset<XBlueprintBlue::XReply> reply = 0) {
  XCommandBuilder builder_(_fbb);
  builder_.add_reply(reply);
  builder_.add_arguments(arguments);
  builder_.add_verb(verb);
  builder_.add_command(command);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XCommand> CreateXCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *command = nullptr,
    const char *verb = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *arguments = nullptr,
    ::flatbuffers::Offset<XBlueprintBlue::XReply> reply = 0) {
  auto command__ = command ? _fbb.CreateString(command) : 0;
  auto verb__ = verb ? _fbb.CreateString(verb) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*arguments) : 0;
  return XBlueprintBlue::CreateXCommand(
      _fbb,
      command__,
      verb__,
      arguments__,
      reply);
}

struct XReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_HELP = 6,
    VT_VALUE = 8,
    VT_MACRO = 10,
    VT_HISTORY = 12
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const ::flatbuffers::String *help() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HELP);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  const XBlueprintBlue::XStatement *macro() const {
    return GetPointer<const XBlueprintBlue::XStatement *>(VT_MACRO);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XStatement>> *history() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XStatement>> *>(VT_HISTORY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_HELP) &&
           verifier.VerifyString(help()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyOffset(verifier, VT_MACRO) &&
           verifier.VerifyTable(macro()) &&
           VerifyOffset(verifier, VT_HISTORY) &&
           verifier.VerifyVector(history()) &&
           verifier.VerifyVectorOfTables(history()) &&
           verifier.EndTable();
  }
};

struct XReplyBuilder {
  typedef XReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(XReply::VT_VERSION, version);
  }
  void add_help(::flatbuffers::Offset<::flatbuffers::String> help) {
    fbb_.AddOffset(XReply::VT_HELP, help);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(XReply::VT_VALUE, value);
  }
  void add_macro(::flatbuffers::Offset<XBlueprintBlue::XStatement> macro) {
    fbb_.AddOffset(XReply::VT_MACRO, macro);
  }
  void add_history(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XStatement>>> history) {
    fbb_.AddOffset(XReply::VT_HISTORY, history);
  }
  explicit XReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<XReply> CreateXReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> help = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0,
    ::flatbuffers::Offset<XBlueprintBlue::XStatement> macro = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XStatement>>> history = 0) {
  XReplyBuilder builder_(_fbb);
  builder_.add_history(history);
  builder_.add_macro(macro);
  builder_.add_value(value);
  builder_.add_help(help);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XReply> CreateXReplyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    const char *help = nullptr,
    const char *value = nullptr,
    ::flatbuffers::Offset<XBlueprintBlue::XStatement> macro = 0,
    const std::vector<::flatbuffers::Offset<XBlueprintBlue::XStatement>> *history = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto help__ = help ? _fbb.CreateString(help) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  auto history__ = history ? _fbb.CreateVector<::flatbuffers::Offset<XBlueprintBlue::XStatement>>(*history) : 0;
  return XBlueprintBlue::CreateXReply(
      _fbb,
      version__,
      help__,
      value__,
      macro,
      history__);
}

struct XStatement FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XStatementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LABEL = 6,
    VT_TIME = 8,
    VT_STMT = 10,
    VT_EXPD = 12,
    VT_SUMMARY = 14,
    VT_SETTINGS = 16
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const ::flatbuffers::String *label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  const ::flatbuffers::String *stmt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STMT);
  }
  const ::flatbuffers::String *expd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXPD);
  }
  const ::flatbuffers::String *summary() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUMMARY);
  }
  const XBlueprintBlue::XSettings *settings() const {
    return GetPointer<const XBlueprintBlue::XSettings *>(VT_SETTINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyField<uint64_t>(verifier, VT_TIME, 8) &&
           VerifyOffsetRequired(verifier, VT_STMT) &&
           verifier.VerifyString(stmt()) &&
           VerifyOffsetRequired(verifier, VT_EXPD) &&
           verifier.VerifyString(expd()) &&
           VerifyOffset(verifier, VT_SUMMARY) &&
           verifier.VerifyString(summary()) &&
           VerifyOffsetRequired(verifier, VT_SETTINGS) &&
           verifier.VerifyTable(settings()) &&
           verifier.EndTable();
  }
};

struct XStatementBuilder {
  typedef XStatement Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(XStatement::VT_ID, id, 0);
  }
  void add_label(::flatbuffers::Offset<::flatbuffers::String> label) {
    fbb_.AddOffset(XStatement::VT_LABEL, label);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(XStatement::VT_TIME, time, 0);
  }
  void add_stmt(::flatbuffers::Offset<::flatbuffers::String> stmt) {
    fbb_.AddOffset(XStatement::VT_STMT, stmt);
  }
  void add_expd(::flatbuffers::Offset<::flatbuffers::String> expd) {
    fbb_.AddOffset(XStatement::VT_EXPD, expd);
  }
  void add_summary(::flatbuffers::Offset<::flatbuffers::String> summary) {
    fbb_.AddOffset(XStatement::VT_SUMMARY, summary);
  }
  void add_settings(::flatbuffers::Offset<XBlueprintBlue::XSettings> settings) {
    fbb_.AddOffset(XStatement::VT_SETTINGS, settings);
  }
  explicit XStatementBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XStatement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XStatement>(end);
    fbb_.Required(o, XStatement::VT_STMT);
    fbb_.Required(o, XStatement::VT_EXPD);
    fbb_.Required(o, XStatement::VT_SETTINGS);
    return o;
  }
};

inline ::flatbuffers::Offset<XStatement> CreateXStatement(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label = 0,
    uint64_t time = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stmt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> expd = 0,
    ::flatbuffers::Offset<::flatbuffers::String> summary = 0,
    ::flatbuffers::Offset<XBlueprintBlue::XSettings> settings = 0) {
  XStatementBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_settings(settings);
  builder_.add_summary(summary);
  builder_.add_expd(expd);
  builder_.add_stmt(stmt);
  builder_.add_label(label);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XStatement> CreateXStatementDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *label = nullptr,
    uint64_t time = 0,
    const char *stmt = nullptr,
    const char *expd = nullptr,
    const char *summary = nullptr,
    ::flatbuffers::Offset<XBlueprintBlue::XSettings> settings = 0) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto stmt__ = stmt ? _fbb.CreateString(stmt) : 0;
  auto expd__ = expd ? _fbb.CreateString(expd) : 0;
  auto summary__ = summary ? _fbb.CreateString(summary) : 0;
  return XBlueprintBlue::CreateXStatement(
      _fbb,
      id,
      label__,
      time,
      stmt__,
      expd__,
      summary__,
      settings);
}

struct XSearch FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XSearchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPRESSION = 4,
    VT_QUOTED = 6,
    VT_FRAGMENTS = 8
  };
  const ::flatbuffers::String *expression() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXPRESSION);
  }
  bool quoted() const {
    return GetField<uint8_t>(VT_QUOTED, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XFragment>> *fragments() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XFragment>> *>(VT_FRAGMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSION) &&
           verifier.VerifyString(expression()) &&
           VerifyField<uint8_t>(verifier, VT_QUOTED, 1) &&
           VerifyOffsetRequired(verifier, VT_FRAGMENTS) &&
           verifier.VerifyVector(fragments()) &&
           verifier.VerifyVectorOfTables(fragments()) &&
           verifier.EndTable();
  }
};

struct XSearchBuilder {
  typedef XSearch Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_expression(::flatbuffers::Offset<::flatbuffers::String> expression) {
    fbb_.AddOffset(XSearch::VT_EXPRESSION, expression);
  }
  void add_quoted(bool quoted) {
    fbb_.AddElement<uint8_t>(XSearch::VT_QUOTED, static_cast<uint8_t>(quoted), 0);
  }
  void add_fragments(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XFragment>>> fragments) {
    fbb_.AddOffset(XSearch::VT_FRAGMENTS, fragments);
  }
  explicit XSearchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XSearch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XSearch>(end);
    fbb_.Required(o, XSearch::VT_EXPRESSION);
    fbb_.Required(o, XSearch::VT_FRAGMENTS);
    return o;
  }
};

inline ::flatbuffers::Offset<XSearch> CreateXSearch(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> expression = 0,
    bool quoted = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XFragment>>> fragments = 0) {
  XSearchBuilder builder_(_fbb);
  builder_.add_fragments(fragments);
  builder_.add_expression(expression);
  builder_.add_quoted(quoted);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XSearch> CreateXSearchDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *expression = nullptr,
    bool quoted = false,
    const std::vector<::flatbuffers::Offset<XBlueprintBlue::XFragment>> *fragments = nullptr) {
  auto expression__ = expression ? _fbb.CreateString(expression) : 0;
  auto fragments__ = fragments ? _fbb.CreateVector<::flatbuffers::Offset<XBlueprintBlue::XFragment>>(*fragments) : 0;
  return XBlueprintBlue::CreateXSearch(
      _fbb,
      expression__,
      quoted,
      fragments__);
}

struct XFragment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XFragmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAGMENT = 4,
    VT_ANCHORED = 6,
    VT_REQUIRE = 8
  };
  const ::flatbuffers::String *fragment() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAGMENT);
  }
  bool anchored() const {
    return GetField<uint8_t>(VT_ANCHORED, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XOption>> *require() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XOption>> *>(VT_REQUIRE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FRAGMENT) &&
           verifier.VerifyString(fragment()) &&
           VerifyField<uint8_t>(verifier, VT_ANCHORED, 1) &&
           VerifyOffsetRequired(verifier, VT_REQUIRE) &&
           verifier.VerifyVector(require()) &&
           verifier.VerifyVectorOfTables(require()) &&
           verifier.EndTable();
  }
};

struct XFragmentBuilder {
  typedef XFragment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fragment(::flatbuffers::Offset<::flatbuffers::String> fragment) {
    fbb_.AddOffset(XFragment::VT_FRAGMENT, fragment);
  }
  void add_anchored(bool anchored) {
    fbb_.AddElement<uint8_t>(XFragment::VT_ANCHORED, static_cast<uint8_t>(anchored), 0);
  }
  void add_require(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XOption>>> require) {
    fbb_.AddOffset(XFragment::VT_REQUIRE, require);
  }
  explicit XFragmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XFragment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XFragment>(end);
    fbb_.Required(o, XFragment::VT_FRAGMENT);
    fbb_.Required(o, XFragment::VT_REQUIRE);
    return o;
  }
};

inline ::flatbuffers::Offset<XFragment> CreateXFragment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> fragment = 0,
    bool anchored = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XOption>>> require = 0) {
  XFragmentBuilder builder_(_fbb);
  builder_.add_require(require);
  builder_.add_fragment(fragment);
  builder_.add_anchored(anchored);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XFragment> CreateXFragmentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *fragment = nullptr,
    bool anchored = false,
    const std::vector<::flatbuffers::Offset<XBlueprintBlue::XOption>> *require = nullptr) {
  auto fragment__ = fragment ? _fbb.CreateString(fragment) : 0;
  auto require__ = require ? _fbb.CreateVector<::flatbuffers::Offset<XBlueprintBlue::XOption>>(*require) : 0;
  return XBlueprintBlue::CreateXFragment(
      _fbb,
      fragment__,
      anchored,
      require__);
}

struct XOption FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XOptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTION = 4,
    VT_FEATURES = 6
  };
  const ::flatbuffers::String *option() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XFeature>> *features() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XFeature>> *>(VT_FEATURES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OPTION) &&
           verifier.VerifyString(option()) &&
           VerifyOffsetRequired(verifier, VT_FEATURES) &&
           verifier.VerifyVector(features()) &&
           verifier.VerifyVectorOfTables(features()) &&
           verifier.EndTable();
  }
};

struct XOptionBuilder {
  typedef XOption Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_option(::flatbuffers::Offset<::flatbuffers::String> option) {
    fbb_.AddOffset(XOption::VT_OPTION, option);
  }
  void add_features(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XFeature>>> features) {
    fbb_.AddOffset(XOption::VT_FEATURES, features);
  }
  explicit XOptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XOption>(end);
    fbb_.Required(o, XOption::VT_OPTION);
    fbb_.Required(o, XOption::VT_FEATURES);
    return o;
  }
};

inline ::flatbuffers::Offset<XOption> CreateXOption(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> option = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XFeature>>> features = 0) {
  XOptionBuilder builder_(_fbb);
  builder_.add_features(features);
  builder_.add_option(option);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XOption> CreateXOptionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *option = nullptr,
    const std::vector<::flatbuffers::Offset<XBlueprintBlue::XFeature>> *features = nullptr) {
  auto option__ = option ? _fbb.CreateString(option) : 0;
  auto features__ = features ? _fbb.CreateVector<::flatbuffers::Offset<XBlueprintBlue::XFeature>>(*features) : 0;
  return XBlueprintBlue::CreateXOption(
      _fbb,
      option__,
      features__);
}

struct XFeature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATURE = 4,
    VT_RULE = 6,
    VT_NEGATE = 8,
    VT_MATCH_TYPE = 10,
    VT_MATCH = 12
  };
  const ::flatbuffers::String *feature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FEATURE);
  }
  const ::flatbuffers::String *rule() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RULE);
  }
  bool negate() const {
    return GetField<uint8_t>(VT_NEGATE, 0) != 0;
  }
  XBlueprintBlue::XCompare match_type() const {
    return static_cast<XBlueprintBlue::XCompare>(GetField<uint8_t>(VT_MATCH_TYPE, 0));
  }
  const void *match() const {
    return GetPointer<const void *>(VT_MATCH);
  }
  template<typename T> const T *match_as() const;
  const XBlueprintBlue::XWord *match_as_text() const {
    return match_type() == XBlueprintBlue::XCompare_text ? static_cast<const XBlueprintBlue::XWord *>(match()) : nullptr;
  }
  const XBlueprintBlue::XLemma *match_as_lemma() const {
    return match_type() == XBlueprintBlue::XCompare_lemma ? static_cast<const XBlueprintBlue::XLemma *>(match()) : nullptr;
  }
  const XBlueprintBlue::XPOS16 *match_as_pos16() const {
    return match_type() == XBlueprintBlue::XCompare_pos16 ? static_cast<const XBlueprintBlue::XPOS16 *>(match()) : nullptr;
  }
  const XBlueprintBlue::XPOS32 *match_as_pos32() const {
    return match_type() == XBlueprintBlue::XCompare_pos32 ? static_cast<const XBlueprintBlue::XPOS32 *>(match()) : nullptr;
  }
  const XBlueprintBlue::XPunctuation *match_as_punctuation() const {
    return match_type() == XBlueprintBlue::XCompare_punctuation ? static_cast<const XBlueprintBlue::XPunctuation *>(match()) : nullptr;
  }
  const XBlueprintBlue::XTransition *match_as_transition() const {
    return match_type() == XBlueprintBlue::XCompare_transition ? static_cast<const XBlueprintBlue::XTransition *>(match()) : nullptr;
  }
  const XBlueprintBlue::XStrongs *match_as_strongs() const {
    return match_type() == XBlueprintBlue::XCompare_strongs ? static_cast<const XBlueprintBlue::XStrongs *>(match()) : nullptr;
  }
  const XBlueprintBlue::XDelta *match_as_delta() const {
    return match_type() == XBlueprintBlue::XCompare_delta ? static_cast<const XBlueprintBlue::XDelta *>(match()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FEATURE) &&
           verifier.VerifyString(feature()) &&
           VerifyOffsetRequired(verifier, VT_RULE) &&
           verifier.VerifyString(rule()) &&
           VerifyField<uint8_t>(verifier, VT_NEGATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_MATCH) &&
           VerifyXCompare(verifier, match(), match_type()) &&
           verifier.EndTable();
  }
};

template<> inline const XBlueprintBlue::XWord *XFeature::match_as<XBlueprintBlue::XWord>() const {
  return match_as_text();
}

template<> inline const XBlueprintBlue::XLemma *XFeature::match_as<XBlueprintBlue::XLemma>() const {
  return match_as_lemma();
}

template<> inline const XBlueprintBlue::XPOS16 *XFeature::match_as<XBlueprintBlue::XPOS16>() const {
  return match_as_pos16();
}

template<> inline const XBlueprintBlue::XPOS32 *XFeature::match_as<XBlueprintBlue::XPOS32>() const {
  return match_as_pos32();
}

template<> inline const XBlueprintBlue::XPunctuation *XFeature::match_as<XBlueprintBlue::XPunctuation>() const {
  return match_as_punctuation();
}

template<> inline const XBlueprintBlue::XTransition *XFeature::match_as<XBlueprintBlue::XTransition>() const {
  return match_as_transition();
}

template<> inline const XBlueprintBlue::XStrongs *XFeature::match_as<XBlueprintBlue::XStrongs>() const {
  return match_as_strongs();
}

template<> inline const XBlueprintBlue::XDelta *XFeature::match_as<XBlueprintBlue::XDelta>() const {
  return match_as_delta();
}

struct XFeatureBuilder {
  typedef XFeature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_feature(::flatbuffers::Offset<::flatbuffers::String> feature) {
    fbb_.AddOffset(XFeature::VT_FEATURE, feature);
  }
  void add_rule(::flatbuffers::Offset<::flatbuffers::String> rule) {
    fbb_.AddOffset(XFeature::VT_RULE, rule);
  }
  void add_negate(bool negate) {
    fbb_.AddElement<uint8_t>(XFeature::VT_NEGATE, static_cast<uint8_t>(negate), 0);
  }
  void add_match_type(XBlueprintBlue::XCompare match_type) {
    fbb_.AddElement<uint8_t>(XFeature::VT_MATCH_TYPE, static_cast<uint8_t>(match_type), 0);
  }
  void add_match(::flatbuffers::Offset<void> match) {
    fbb_.AddOffset(XFeature::VT_MATCH, match);
  }
  explicit XFeatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XFeature>(end);
    fbb_.Required(o, XFeature::VT_FEATURE);
    fbb_.Required(o, XFeature::VT_RULE);
    fbb_.Required(o, XFeature::VT_MATCH);
    return o;
  }
};

inline ::flatbuffers::Offset<XFeature> CreateXFeature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> feature = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rule = 0,
    bool negate = false,
    XBlueprintBlue::XCompare match_type = XBlueprintBlue::XCompare_NONE,
    ::flatbuffers::Offset<void> match = 0) {
  XFeatureBuilder builder_(_fbb);
  builder_.add_match(match);
  builder_.add_rule(rule);
  builder_.add_feature(feature);
  builder_.add_match_type(match_type);
  builder_.add_negate(negate);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XFeature> CreateXFeatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *feature = nullptr,
    const char *rule = nullptr,
    bool negate = false,
    XBlueprintBlue::XCompare match_type = XBlueprintBlue::XCompare_NONE,
    ::flatbuffers::Offset<void> match = 0) {
  auto feature__ = feature ? _fbb.CreateString(feature) : 0;
  auto rule__ = rule ? _fbb.CreateString(rule) : 0;
  return XBlueprintBlue::CreateXFeature(
      _fbb,
      feature__,
      rule__,
      negate,
      match_type,
      match);
}

struct XLex FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XLexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_PHONETICS = 6
  };
  uint16_t key() const {
    return GetField<uint16_t>(VT_KEY, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *phonetics() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PHONETICS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_KEY, 2) &&
           VerifyOffsetRequired(verifier, VT_PHONETICS) &&
           verifier.VerifyVector(phonetics()) &&
           verifier.VerifyVectorOfStrings(phonetics()) &&
           verifier.EndTable();
  }
};

struct XLexBuilder {
  typedef XLex Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(uint16_t key) {
    fbb_.AddElement<uint16_t>(XLex::VT_KEY, key, 0);
  }
  void add_phonetics(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> phonetics) {
    fbb_.AddOffset(XLex::VT_PHONETICS, phonetics);
  }
  explicit XLexBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XLex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XLex>(end);
    fbb_.Required(o, XLex::VT_PHONETICS);
    return o;
  }
};

inline ::flatbuffers::Offset<XLex> CreateXLex(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> phonetics = 0) {
  XLexBuilder builder_(_fbb);
  builder_.add_phonetics(phonetics);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XLex> CreateXLexDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t key = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *phonetics = nullptr) {
  auto phonetics__ = phonetics ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*phonetics) : 0;
  return XBlueprintBlue::CreateXLex(
      _fbb,
      key,
      phonetics__);
}

struct XWord FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XWordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEX = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XLex>> *lex() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XLex>> *>(VT_LEX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LEX) &&
           verifier.VerifyVector(lex()) &&
           verifier.VerifyVectorOfTables(lex()) &&
           verifier.EndTable();
  }
};

struct XWordBuilder {
  typedef XWord Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lex(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XLex>>> lex) {
    fbb_.AddOffset(XWord::VT_LEX, lex);
  }
  explicit XWordBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XWord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XWord>(end);
    fbb_.Required(o, XWord::VT_LEX);
    return o;
  }
};

inline ::flatbuffers::Offset<XWord> CreateXWord(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XLex>>> lex = 0) {
  XWordBuilder builder_(_fbb);
  builder_.add_lex(lex);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XWord> CreateXWordDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<XBlueprintBlue::XLex>> *lex = nullptr) {
  auto lex__ = lex ? _fbb.CreateVector<::flatbuffers::Offset<XBlueprintBlue::XLex>>(*lex) : 0;
  return XBlueprintBlue::CreateXWord(
      _fbb,
      lex__);
}

struct XLemma FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XLemmaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEMMATA = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XLex>> *lemmata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XLex>> *>(VT_LEMMATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LEMMATA) &&
           verifier.VerifyVector(lemmata()) &&
           verifier.VerifyVectorOfTables(lemmata()) &&
           verifier.EndTable();
  }
};

struct XLemmaBuilder {
  typedef XLemma Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lemmata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XLex>>> lemmata) {
    fbb_.AddOffset(XLemma::VT_LEMMATA, lemmata);
  }
  explicit XLemmaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XLemma> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XLemma>(end);
    fbb_.Required(o, XLemma::VT_LEMMATA);
    return o;
  }
};

inline ::flatbuffers::Offset<XLemma> CreateXLemma(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XBlueprintBlue::XLex>>> lemmata = 0) {
  XLemmaBuilder builder_(_fbb);
  builder_.add_lemmata(lemmata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XLemma> CreateXLemmaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<XBlueprintBlue::XLex>> *lemmata = nullptr) {
  auto lemmata__ = lemmata ? _fbb.CreateVector<::flatbuffers::Offset<XBlueprintBlue::XLex>>(*lemmata) : 0;
  return XBlueprintBlue::CreateXLemma(
      _fbb,
      lemmata__);
}

struct XPOS32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XPOS32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4
  };
  uint32_t pos() const {
    return GetField<uint32_t>(VT_POS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_POS, 4) &&
           verifier.EndTable();
  }
};

struct XPOS32Builder {
  typedef XPOS32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(uint32_t pos) {
    fbb_.AddElement<uint32_t>(XPOS32::VT_POS, pos, 0);
  }
  explicit XPOS32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XPOS32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XPOS32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<XPOS32> CreateXPOS32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t pos = 0) {
  XPOS32Builder builder_(_fbb);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct XPOS16 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XPOS16Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PNPOS = 4
  };
  uint16_t pnpos() const {
    return GetField<uint16_t>(VT_PNPOS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PNPOS, 2) &&
           verifier.EndTable();
  }
};

struct XPOS16Builder {
  typedef XPOS16 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pnpos(uint16_t pnpos) {
    fbb_.AddElement<uint16_t>(XPOS16::VT_PNPOS, pnpos, 0);
  }
  explicit XPOS16Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XPOS16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XPOS16>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<XPOS16> CreateXPOS16(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t pnpos = 0) {
  XPOS16Builder builder_(_fbb);
  builder_.add_pnpos(pnpos);
  return builder_.Finish();
}

struct XPunctuation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XPunctuationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITS = 4
  };
  uint8_t bits() const {
    return GetField<uint8_t>(VT_BITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BITS, 1) &&
           verifier.EndTable();
  }
};

struct XPunctuationBuilder {
  typedef XPunctuation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bits(uint8_t bits) {
    fbb_.AddElement<uint8_t>(XPunctuation::VT_BITS, bits, 0);
  }
  explicit XPunctuationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XPunctuation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XPunctuation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<XPunctuation> CreateXPunctuation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t bits = 0) {
  XPunctuationBuilder builder_(_fbb);
  builder_.add_bits(bits);
  return builder_.Finish();
}

struct XTransition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XTransitionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITS = 4
  };
  uint8_t bits() const {
    return GetField<uint8_t>(VT_BITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BITS, 1) &&
           verifier.EndTable();
  }
};

struct XTransitionBuilder {
  typedef XTransition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bits(uint8_t bits) {
    fbb_.AddElement<uint8_t>(XTransition::VT_BITS, bits, 0);
  }
  explicit XTransitionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XTransition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XTransition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<XTransition> CreateXTransition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t bits = 0) {
  XTransitionBuilder builder_(_fbb);
  builder_.add_bits(bits);
  return builder_.Finish();
}

struct XStrongs FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XStrongsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANG = 4,
    VT_NUMBER = 6
  };
  XBlueprintBlue::XLangEnum lang() const {
    return static_cast<XBlueprintBlue::XLangEnum>(GetField<int8_t>(VT_LANG, 0));
  }
  uint16_t number() const {
    return GetField<uint16_t>(VT_NUMBER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LANG, 1) &&
           VerifyField<uint16_t>(verifier, VT_NUMBER, 2) &&
           verifier.EndTable();
  }
};

struct XStrongsBuilder {
  typedef XStrongs Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lang(XBlueprintBlue::XLangEnum lang) {
    fbb_.AddElement<int8_t>(XStrongs::VT_LANG, static_cast<int8_t>(lang), 0);
  }
  void add_number(uint16_t number) {
    fbb_.AddElement<uint16_t>(XStrongs::VT_NUMBER, number, 0);
  }
  explicit XStrongsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XStrongs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XStrongs>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<XStrongs> CreateXStrongs(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    XBlueprintBlue::XLangEnum lang = XBlueprintBlue::XLangEnum_X,
    uint16_t number = 0) {
  XStrongsBuilder builder_(_fbb);
  builder_.add_number(number);
  builder_.add_lang(lang);
  return builder_.Finish();
}

struct XDelta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XDeltaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIFFERS = 4
  };
  bool differs() const {
    return GetField<uint8_t>(VT_DIFFERS, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DIFFERS, 1) &&
           verifier.EndTable();
  }
};

struct XDeltaBuilder {
  typedef XDelta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_differs(bool differs) {
    fbb_.AddElement<uint8_t>(XDelta::VT_DIFFERS, static_cast<uint8_t>(differs), 1);
  }
  explicit XDeltaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XDelta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XDelta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<XDelta> CreateXDelta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool differs = true) {
  XDeltaBuilder builder_(_fbb);
  builder_.add_differs(differs);
  return builder_.Finish();
}

struct XSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIMILARITY = 4,
    VT_SPAN = 6,
    VT_LEXICON = 8,
    VT_DISPLAY = 10,
    VT_FORMAT = 12
  };
  const ::flatbuffers::String *similarity() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIMILARITY);
  }
  uint16_t span() const {
    return GetField<uint16_t>(VT_SPAN, 0);
  }
  XBlueprintBlue::XLexEnum lexicon() const {
    return static_cast<XBlueprintBlue::XLexEnum>(GetField<int8_t>(VT_LEXICON, 3));
  }
  XBlueprintBlue::XOutEnum display() const {
    return static_cast<XBlueprintBlue::XOutEnum>(GetField<int8_t>(VT_DISPLAY, 1));
  }
  XBlueprintBlue::XFmtEnum format() const {
    return static_cast<XBlueprintBlue::XFmtEnum>(GetField<int8_t>(VT_FORMAT, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SIMILARITY) &&
           verifier.VerifyString(similarity()) &&
           VerifyField<uint16_t>(verifier, VT_SPAN, 2) &&
           VerifyField<int8_t>(verifier, VT_LEXICON, 1) &&
           VerifyField<int8_t>(verifier, VT_DISPLAY, 1) &&
           VerifyField<int8_t>(verifier, VT_FORMAT, 1) &&
           verifier.EndTable();
  }
};

struct XSettingsBuilder {
  typedef XSettings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_similarity(::flatbuffers::Offset<::flatbuffers::String> similarity) {
    fbb_.AddOffset(XSettings::VT_SIMILARITY, similarity);
  }
  void add_span(uint16_t span) {
    fbb_.AddElement<uint16_t>(XSettings::VT_SPAN, span, 0);
  }
  void add_lexicon(XBlueprintBlue::XLexEnum lexicon) {
    fbb_.AddElement<int8_t>(XSettings::VT_LEXICON, static_cast<int8_t>(lexicon), 3);
  }
  void add_display(XBlueprintBlue::XOutEnum display) {
    fbb_.AddElement<int8_t>(XSettings::VT_DISPLAY, static_cast<int8_t>(display), 1);
  }
  void add_format(XBlueprintBlue::XFmtEnum format) {
    fbb_.AddElement<int8_t>(XSettings::VT_FORMAT, static_cast<int8_t>(format), 0);
  }
  explicit XSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XSettings>(end);
    fbb_.Required(o, XSettings::VT_SIMILARITY);
    return o;
  }
};

inline ::flatbuffers::Offset<XSettings> CreateXSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> similarity = 0,
    uint16_t span = 0,
    XBlueprintBlue::XLexEnum lexicon = XBlueprintBlue::XLexEnum_BOTH,
    XBlueprintBlue::XOutEnum display = XBlueprintBlue::XOutEnum_AV,
    XBlueprintBlue::XFmtEnum format = XBlueprintBlue::XFmtEnum_JSON) {
  XSettingsBuilder builder_(_fbb);
  builder_.add_similarity(similarity);
  builder_.add_span(span);
  builder_.add_format(format);
  builder_.add_display(display);
  builder_.add_lexicon(lexicon);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XSettings> CreateXSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *similarity = nullptr,
    uint16_t span = 0,
    XBlueprintBlue::XLexEnum lexicon = XBlueprintBlue::XLexEnum_BOTH,
    XBlueprintBlue::XOutEnum display = XBlueprintBlue::XOutEnum_AV,
    XBlueprintBlue::XFmtEnum format = XBlueprintBlue::XFmtEnum_JSON) {
  auto similarity__ = similarity ? _fbb.CreateString(similarity) : 0;
  return XBlueprintBlue::CreateXSettings(
      _fbb,
      similarity__,
      span,
      lexicon,
      display,
      format);
}

struct XScope FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XScopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOOK = 4,
    VT_CHAPTER = 6,
    VT_VERSE = 8,
    VT_VCOUNT = 10
  };
  uint8_t book() const {
    return GetField<uint8_t>(VT_BOOK, 0);
  }
  uint8_t chapter() const {
    return GetField<uint8_t>(VT_CHAPTER, 0);
  }
  uint8_t verse() const {
    return GetField<uint8_t>(VT_VERSE, 1);
  }
  uint8_t vcount() const {
    return GetField<uint8_t>(VT_VCOUNT, 255);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BOOK, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHAPTER, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSE, 1) &&
           VerifyField<uint8_t>(verifier, VT_VCOUNT, 1) &&
           verifier.EndTable();
  }
};

struct XScopeBuilder {
  typedef XScope Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_book(uint8_t book) {
    fbb_.AddElement<uint8_t>(XScope::VT_BOOK, book, 0);
  }
  void add_chapter(uint8_t chapter) {
    fbb_.AddElement<uint8_t>(XScope::VT_CHAPTER, chapter, 0);
  }
  void add_verse(uint8_t verse) {
    fbb_.AddElement<uint8_t>(XScope::VT_VERSE, verse, 1);
  }
  void add_vcount(uint8_t vcount) {
    fbb_.AddElement<uint8_t>(XScope::VT_VCOUNT, vcount, 255);
  }
  explicit XScopeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XScope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XScope>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<XScope> CreateXScope(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t book = 0,
    uint8_t chapter = 0,
    uint8_t verse = 1,
    uint8_t vcount = 255) {
  XScopeBuilder builder_(_fbb);
  builder_.add_vcount(vcount);
  builder_.add_verse(verse);
  builder_.add_chapter(chapter);
  builder_.add_book(book);
  return builder_.Finish();
}

inline bool VerifyXCompare(::flatbuffers::Verifier &verifier, const void *obj, XCompare type) {
  switch (type) {
    case XCompare_NONE: {
      return true;
    }
    case XCompare_text: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XWord *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_lemma: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XLemma *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_pos16: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XPOS16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_pos32: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XPOS32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_punctuation: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XPunctuation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_transition: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XTransition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_strongs: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XStrongs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_delta: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XDelta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyXCompareVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyXCompare(
        verifier,  values->Get(i), types->GetEnum<XCompare>(i))) {
      return false;
    }
  }
  return true;
}

inline const XBlueprintBlue::XBlueprint *GetXBlueprint(const void *buf) {
  return ::flatbuffers::GetRoot<XBlueprintBlue::XBlueprint>(buf);
}

inline const XBlueprintBlue::XBlueprint *GetSizePrefixedXBlueprint(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<XBlueprintBlue::XBlueprint>(buf);
}

inline bool VerifyXBlueprintBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<XBlueprintBlue::XBlueprint>(nullptr);
}

inline bool VerifySizePrefixedXBlueprintBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<XBlueprintBlue::XBlueprint>(nullptr);
}

inline void FinishXBlueprintBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<XBlueprintBlue::XBlueprint> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedXBlueprintBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<XBlueprintBlue::XBlueprint> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace XBlueprintBlue

#endif  // FLATBUFFERS_GENERATED_BLUEPRINTBLUE_XBLUEPRINTBLUE_H_
