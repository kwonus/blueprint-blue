// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BLUEPRINTBLUE_XBLUEPRINTBLUE_H_
#define FLATBUFFERS_GENERATED_BLUEPRINTBLUE_XBLUEPRINTBLUE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace XBlueprintBlue {

struct XUser;
struct XUserBuilder;

struct XBlueprint;
struct XBlueprintBuilder;

struct XCommand;
struct XCommandBuilder;

struct XSearch;
struct XSearchBuilder;

struct XSegment;
struct XSegmentBuilder;

struct XFragment;
struct XFragmentBuilder;

struct XFeature;
struct XFeatureBuilder;

struct XWord;
struct XWordBuilder;

struct XLemma;
struct XLemmaBuilder;

struct XPOS32;
struct XPOS32Builder;

struct XPOS16;
struct XPOS16Builder;

struct XPunctuation;
struct XPunctuationBuilder;

struct XTransition;
struct XTransitionBuilder;

struct XStrongs;
struct XStrongsBuilder;

struct XDelta;
struct XDeltaBuilder;

struct XSettings;
struct XSettingsBuilder;

struct XScope;
struct XScopeBuilder;

enum XLexEnum : int8_t {
  XLexEnum_AV = 0,
  XLexEnum_AVX = 1,
  XLexEnum_MIN = XLexEnum_AV,
  XLexEnum_MAX = XLexEnum_AVX
};

inline const XLexEnum (&EnumValuesXLexEnum())[2] {
  static const XLexEnum values[] = {
    XLexEnum_AV,
    XLexEnum_AVX
  };
  return values;
}

inline const char * const *EnumNamesXLexEnum() {
  static const char * const names[3] = {
    "AV",
    "AVX",
    nullptr
  };
  return names;
}

inline const char *EnumNameXLexEnum(XLexEnum e) {
  if (flatbuffers::IsOutRange(e, XLexEnum_AV, XLexEnum_AVX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXLexEnum()[index];
}

enum XFmtEnum : int8_t {
  XFmtEnum_JSON = 0,
  XFmtEnum_TEXT = 1,
  XFmtEnum_HTML = 2,
  XFmtEnum_MD = 3,
  XFmtEnum_MIN = XFmtEnum_JSON,
  XFmtEnum_MAX = XFmtEnum_MD
};

inline const XFmtEnum (&EnumValuesXFmtEnum())[4] {
  static const XFmtEnum values[] = {
    XFmtEnum_JSON,
    XFmtEnum_TEXT,
    XFmtEnum_HTML,
    XFmtEnum_MD
  };
  return values;
}

inline const char * const *EnumNamesXFmtEnum() {
  static const char * const names[5] = {
    "JSON",
    "TEXT",
    "HTML",
    "MD",
    nullptr
  };
  return names;
}

inline const char *EnumNameXFmtEnum(XFmtEnum e) {
  if (flatbuffers::IsOutRange(e, XFmtEnum_JSON, XFmtEnum_MD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXFmtEnum()[index];
}

enum XLangEnum : int8_t {
  XLangEnum_X = 0,
  XLangEnum_H = 1,
  XLangEnum_G = 2,
  XLangEnum_MIN = XLangEnum_X,
  XLangEnum_MAX = XLangEnum_G
};

inline const XLangEnum (&EnumValuesXLangEnum())[3] {
  static const XLangEnum values[] = {
    XLangEnum_X,
    XLangEnum_H,
    XLangEnum_G
  };
  return values;
}

inline const char * const *EnumNamesXLangEnum() {
  static const char * const names[4] = {
    "X",
    "H",
    "G",
    nullptr
  };
  return names;
}

inline const char *EnumNameXLangEnum(XLangEnum e) {
  if (flatbuffers::IsOutRange(e, XLangEnum_X, XLangEnum_G)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXLangEnum()[index];
}

enum XUserEnum : int8_t {
  XUserEnum_ANONYMOUS = 0,
  XUserEnum_EXISTING = 1,
  XUserEnum_NEW = 2,
  XUserEnum_RESET = 3,
  XUserEnum_UNKNOWN = 4,
  XUserEnum_MIN = XUserEnum_ANONYMOUS,
  XUserEnum_MAX = XUserEnum_UNKNOWN
};

inline const XUserEnum (&EnumValuesXUserEnum())[5] {
  static const XUserEnum values[] = {
    XUserEnum_ANONYMOUS,
    XUserEnum_EXISTING,
    XUserEnum_NEW,
    XUserEnum_RESET,
    XUserEnum_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesXUserEnum() {
  static const char * const names[6] = {
    "ANONYMOUS",
    "EXISTING",
    "NEW",
    "RESET",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameXUserEnum(XUserEnum e) {
  if (flatbuffers::IsOutRange(e, XUserEnum_ANONYMOUS, XUserEnum_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXUserEnum()[index];
}

enum XStatusEnum : int8_t {
  XStatusEnum_COMPLETED = 0,
  XStatusEnum_ACTION_REQUIRED = 1,
  XStatusEnum_FEEDBACK_EXPECTED = 2,
  XStatusEnum_ERROR = 3,
  XStatusEnum_UNKNOWN = 4,
  XStatusEnum_MIN = XStatusEnum_COMPLETED,
  XStatusEnum_MAX = XStatusEnum_UNKNOWN
};

inline const XStatusEnum (&EnumValuesXStatusEnum())[5] {
  static const XStatusEnum values[] = {
    XStatusEnum_COMPLETED,
    XStatusEnum_ACTION_REQUIRED,
    XStatusEnum_FEEDBACK_EXPECTED,
    XStatusEnum_ERROR,
    XStatusEnum_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesXStatusEnum() {
  static const char * const names[6] = {
    "COMPLETED",
    "ACTION_REQUIRED",
    "FEEDBACK_EXPECTED",
    "ERROR",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameXStatusEnum(XStatusEnum e) {
  if (flatbuffers::IsOutRange(e, XStatusEnum_COMPLETED, XStatusEnum_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXStatusEnum()[index];
}

enum XCompare : uint8_t {
  XCompare_NONE = 0,
  XCompare_text = 1,
  XCompare_lemma = 2,
  XCompare_pos16 = 3,
  XCompare_pos32 = 4,
  XCompare_punctuation = 5,
  XCompare_transition = 6,
  XCompare_strongs = 7,
  XCompare_delta = 8,
  XCompare_MIN = XCompare_NONE,
  XCompare_MAX = XCompare_delta
};

inline const XCompare (&EnumValuesXCompare())[9] {
  static const XCompare values[] = {
    XCompare_NONE,
    XCompare_text,
    XCompare_lemma,
    XCompare_pos16,
    XCompare_pos32,
    XCompare_punctuation,
    XCompare_transition,
    XCompare_strongs,
    XCompare_delta
  };
  return values;
}

inline const char * const *EnumNamesXCompare() {
  static const char * const names[10] = {
    "NONE",
    "text",
    "lemma",
    "pos16",
    "pos32",
    "punctuation",
    "transition",
    "strongs",
    "delta",
    nullptr
  };
  return names;
}

inline const char *EnumNameXCompare(XCompare e) {
  if (flatbuffers::IsOutRange(e, XCompare_NONE, XCompare_delta)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXCompare()[index];
}

template<typename T> struct XCompareTraits {
  static const XCompare enum_value = XCompare_NONE;
};

template<> struct XCompareTraits<XBlueprintBlue::XWord> {
  static const XCompare enum_value = XCompare_text;
};

template<> struct XCompareTraits<XBlueprintBlue::XLemma> {
  static const XCompare enum_value = XCompare_lemma;
};

template<> struct XCompareTraits<XBlueprintBlue::XPOS16> {
  static const XCompare enum_value = XCompare_pos16;
};

template<> struct XCompareTraits<XBlueprintBlue::XPOS32> {
  static const XCompare enum_value = XCompare_pos32;
};

template<> struct XCompareTraits<XBlueprintBlue::XPunctuation> {
  static const XCompare enum_value = XCompare_punctuation;
};

template<> struct XCompareTraits<XBlueprintBlue::XTransition> {
  static const XCompare enum_value = XCompare_transition;
};

template<> struct XCompareTraits<XBlueprintBlue::XStrongs> {
  static const XCompare enum_value = XCompare_strongs;
};

template<> struct XCompareTraits<XBlueprintBlue::XDelta> {
  static const XCompare enum_value = XCompare_delta;
};

bool VerifyXCompare(flatbuffers::Verifier &verifier, const void *obj, XCompare type);
bool VerifyXCompareVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct XUser FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XUserBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERNAME = 4,
    VT_DISPOSITION = 6
  };
  const flatbuffers::String *username() const {
    return GetPointer<const flatbuffers::String *>(VT_USERNAME);
  }
  XBlueprintBlue::XUserEnum disposition() const {
    return static_cast<XBlueprintBlue::XUserEnum>(GetField<int8_t>(VT_DISPOSITION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_USERNAME) &&
           verifier.VerifyString(username()) &&
           VerifyField<int8_t>(verifier, VT_DISPOSITION, 1) &&
           verifier.EndTable();
  }
};

struct XUserBuilder {
  typedef XUser Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_username(flatbuffers::Offset<flatbuffers::String> username) {
    fbb_.AddOffset(XUser::VT_USERNAME, username);
  }
  void add_disposition(XBlueprintBlue::XUserEnum disposition) {
    fbb_.AddElement<int8_t>(XUser::VT_DISPOSITION, static_cast<int8_t>(disposition), 0);
  }
  explicit XUserBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XUser> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XUser>(end);
    fbb_.Required(o, XUser::VT_USERNAME);
    return o;
  }
};

inline flatbuffers::Offset<XUser> CreateXUser(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> username = 0,
    XBlueprintBlue::XUserEnum disposition = XBlueprintBlue::XUserEnum_ANONYMOUS) {
  XUserBuilder builder_(_fbb);
  builder_.add_username(username);
  builder_.add_disposition(disposition);
  return builder_.Finish();
}

inline flatbuffers::Offset<XUser> CreateXUserDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *username = nullptr,
    XBlueprintBlue::XUserEnum disposition = XBlueprintBlue::XUserEnum_ANONYMOUS) {
  auto username__ = username ? _fbb.CreateString(username) : 0;
  return XBlueprintBlue::CreateXUser(
      _fbb,
      username__,
      disposition);
}

struct XBlueprint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XBlueprintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETTINGS = 4,
    VT_SEARCH = 6,
    VT_SCOPE = 8,
    VT_SINGLETON = 10,
    VT_STATUS = 12,
    VT_HELP = 14,
    VT_MESSAGES = 16
  };
  const XBlueprintBlue::XSettings *settings() const {
    return GetPointer<const XBlueprintBlue::XSettings *>(VT_SETTINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XSearch>> *search() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XSearch>> *>(VT_SEARCH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XScope>> *scope() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XScope>> *>(VT_SCOPE);
  }
  const XBlueprintBlue::XCommand *singleton() const {
    return GetPointer<const XBlueprintBlue::XCommand *>(VT_SINGLETON);
  }
  XBlueprintBlue::XStatusEnum status() const {
    return static_cast<XBlueprintBlue::XStatusEnum>(GetField<int8_t>(VT_STATUS, 4));
  }
  const flatbuffers::String *help() const {
    return GetPointer<const flatbuffers::String *>(VT_HELP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SETTINGS) &&
           verifier.VerifyTable(settings()) &&
           VerifyOffset(verifier, VT_SEARCH) &&
           verifier.VerifyVector(search()) &&
           verifier.VerifyVectorOfTables(search()) &&
           VerifyOffset(verifier, VT_SCOPE) &&
           verifier.VerifyVector(scope()) &&
           verifier.VerifyVectorOfTables(scope()) &&
           VerifyOffset(verifier, VT_SINGLETON) &&
           verifier.VerifyTable(singleton()) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffsetRequired(verifier, VT_HELP) &&
           verifier.VerifyString(help()) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfStrings(messages()) &&
           verifier.EndTable();
  }
};

struct XBlueprintBuilder {
  typedef XBlueprint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_settings(flatbuffers::Offset<XBlueprintBlue::XSettings> settings) {
    fbb_.AddOffset(XBlueprint::VT_SETTINGS, settings);
  }
  void add_search(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XSearch>>> search) {
    fbb_.AddOffset(XBlueprint::VT_SEARCH, search);
  }
  void add_scope(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XScope>>> scope) {
    fbb_.AddOffset(XBlueprint::VT_SCOPE, scope);
  }
  void add_singleton(flatbuffers::Offset<XBlueprintBlue::XCommand> singleton) {
    fbb_.AddOffset(XBlueprint::VT_SINGLETON, singleton);
  }
  void add_status(XBlueprintBlue::XStatusEnum status) {
    fbb_.AddElement<int8_t>(XBlueprint::VT_STATUS, static_cast<int8_t>(status), 4);
  }
  void add_help(flatbuffers::Offset<flatbuffers::String> help) {
    fbb_.AddOffset(XBlueprint::VT_HELP, help);
  }
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> messages) {
    fbb_.AddOffset(XBlueprint::VT_MESSAGES, messages);
  }
  explicit XBlueprintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XBlueprint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XBlueprint>(end);
    fbb_.Required(o, XBlueprint::VT_SETTINGS);
    fbb_.Required(o, XBlueprint::VT_HELP);
    return o;
  }
};

inline flatbuffers::Offset<XBlueprint> CreateXBlueprint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<XBlueprintBlue::XSettings> settings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XSearch>>> search = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XScope>>> scope = 0,
    flatbuffers::Offset<XBlueprintBlue::XCommand> singleton = 0,
    XBlueprintBlue::XStatusEnum status = XBlueprintBlue::XStatusEnum_UNKNOWN,
    flatbuffers::Offset<flatbuffers::String> help = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> messages = 0) {
  XBlueprintBuilder builder_(_fbb);
  builder_.add_messages(messages);
  builder_.add_help(help);
  builder_.add_singleton(singleton);
  builder_.add_scope(scope);
  builder_.add_search(search);
  builder_.add_settings(settings);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<XBlueprint> CreateXBlueprintDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<XBlueprintBlue::XSettings> settings = 0,
    const std::vector<flatbuffers::Offset<XBlueprintBlue::XSearch>> *search = nullptr,
    const std::vector<flatbuffers::Offset<XBlueprintBlue::XScope>> *scope = nullptr,
    flatbuffers::Offset<XBlueprintBlue::XCommand> singleton = 0,
    XBlueprintBlue::XStatusEnum status = XBlueprintBlue::XStatusEnum_UNKNOWN,
    const char *help = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *messages = nullptr) {
  auto search__ = search ? _fbb.CreateVector<flatbuffers::Offset<XBlueprintBlue::XSearch>>(*search) : 0;
  auto scope__ = scope ? _fbb.CreateVector<flatbuffers::Offset<XBlueprintBlue::XScope>>(*scope) : 0;
  auto help__ = help ? _fbb.CreateString(help) : 0;
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*messages) : 0;
  return XBlueprintBlue::CreateXBlueprint(
      _fbb,
      settings,
      search__,
      scope__,
      singleton,
      status,
      help__,
      messages__);
}

struct XCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_VERB = 6,
    VT_ARGUMENTS = 8,
    VT_RESPONSE = 10
  };
  const flatbuffers::String *command() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMAND);
  }
  const flatbuffers::String *verb() const {
    return GetPointer<const flatbuffers::String *>(VT_VERB);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGUMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *response() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_RESPONSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           VerifyOffsetRequired(verifier, VT_VERB) &&
           verifier.VerifyString(verb()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfStrings(arguments()) &&
           VerifyOffsetRequired(verifier, VT_RESPONSE) &&
           verifier.VerifyVector(response()) &&
           verifier.VerifyVectorOfStrings(response()) &&
           verifier.EndTable();
  }
};

struct XCommandBuilder {
  typedef XCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_command(flatbuffers::Offset<flatbuffers::String> command) {
    fbb_.AddOffset(XCommand::VT_COMMAND, command);
  }
  void add_verb(flatbuffers::Offset<flatbuffers::String> verb) {
    fbb_.AddOffset(XCommand::VT_VERB, verb);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> arguments) {
    fbb_.AddOffset(XCommand::VT_ARGUMENTS, arguments);
  }
  void add_response(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> response) {
    fbb_.AddOffset(XCommand::VT_RESPONSE, response);
  }
  explicit XCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XCommand>(end);
    fbb_.Required(o, XCommand::VT_COMMAND);
    fbb_.Required(o, XCommand::VT_VERB);
    fbb_.Required(o, XCommand::VT_RESPONSE);
    return o;
  }
};

inline flatbuffers::Offset<XCommand> CreateXCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> command = 0,
    flatbuffers::Offset<flatbuffers::String> verb = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> arguments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> response = 0) {
  XCommandBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_arguments(arguments);
  builder_.add_verb(verb);
  builder_.add_command(command);
  return builder_.Finish();
}

inline flatbuffers::Offset<XCommand> CreateXCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *command = nullptr,
    const char *verb = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *arguments = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *response = nullptr) {
  auto command__ = command ? _fbb.CreateString(command) : 0;
  auto verb__ = verb ? _fbb.CreateString(verb) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*arguments) : 0;
  auto response__ = response ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*response) : 0;
  return XBlueprintBlue::CreateXCommand(
      _fbb,
      command__,
      verb__,
      arguments__,
      response__);
}

struct XSearch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XSearchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEARCH = 4,
    VT_NEGATE = 6,
    VT_QUOTED = 8,
    VT_SEGMENTS = 10
  };
  const flatbuffers::String *search() const {
    return GetPointer<const flatbuffers::String *>(VT_SEARCH);
  }
  bool negate() const {
    return GetField<uint8_t>(VT_NEGATE, 0) != 0;
  }
  bool quoted() const {
    return GetField<uint8_t>(VT_QUOTED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XSegment>> *segments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XSegment>> *>(VT_SEGMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SEARCH) &&
           verifier.VerifyString(search()) &&
           VerifyField<uint8_t>(verifier, VT_NEGATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_QUOTED, 1) &&
           VerifyOffsetRequired(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(segments()) &&
           verifier.VerifyVectorOfTables(segments()) &&
           verifier.EndTable();
  }
};

struct XSearchBuilder {
  typedef XSearch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_search(flatbuffers::Offset<flatbuffers::String> search) {
    fbb_.AddOffset(XSearch::VT_SEARCH, search);
  }
  void add_negate(bool negate) {
    fbb_.AddElement<uint8_t>(XSearch::VT_NEGATE, static_cast<uint8_t>(negate), 0);
  }
  void add_quoted(bool quoted) {
    fbb_.AddElement<uint8_t>(XSearch::VT_QUOTED, static_cast<uint8_t>(quoted), 0);
  }
  void add_segments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XSegment>>> segments) {
    fbb_.AddOffset(XSearch::VT_SEGMENTS, segments);
  }
  explicit XSearchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XSearch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XSearch>(end);
    fbb_.Required(o, XSearch::VT_SEARCH);
    fbb_.Required(o, XSearch::VT_SEGMENTS);
    return o;
  }
};

inline flatbuffers::Offset<XSearch> CreateXSearch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> search = 0,
    bool negate = false,
    bool quoted = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XSegment>>> segments = 0) {
  XSearchBuilder builder_(_fbb);
  builder_.add_segments(segments);
  builder_.add_search(search);
  builder_.add_quoted(quoted);
  builder_.add_negate(negate);
  return builder_.Finish();
}

inline flatbuffers::Offset<XSearch> CreateXSearchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *search = nullptr,
    bool negate = false,
    bool quoted = false,
    const std::vector<flatbuffers::Offset<XBlueprintBlue::XSegment>> *segments = nullptr) {
  auto search__ = search ? _fbb.CreateString(search) : 0;
  auto segments__ = segments ? _fbb.CreateVector<flatbuffers::Offset<XBlueprintBlue::XSegment>>(*segments) : 0;
  return XBlueprintBlue::CreateXSearch(
      _fbb,
      search__,
      negate,
      quoted,
      segments__);
}

struct XSegment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENT = 4,
    VT_ANCHORED = 6,
    VT_FRAGMENTS = 8
  };
  const flatbuffers::String *segment() const {
    return GetPointer<const flatbuffers::String *>(VT_SEGMENT);
  }
  bool anchored() const {
    return GetField<uint8_t>(VT_ANCHORED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XFragment>> *fragments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XFragment>> *>(VT_FRAGMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SEGMENT) &&
           verifier.VerifyString(segment()) &&
           VerifyField<uint8_t>(verifier, VT_ANCHORED, 1) &&
           VerifyOffsetRequired(verifier, VT_FRAGMENTS) &&
           verifier.VerifyVector(fragments()) &&
           verifier.VerifyVectorOfTables(fragments()) &&
           verifier.EndTable();
  }
};

struct XSegmentBuilder {
  typedef XSegment Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_segment(flatbuffers::Offset<flatbuffers::String> segment) {
    fbb_.AddOffset(XSegment::VT_SEGMENT, segment);
  }
  void add_anchored(bool anchored) {
    fbb_.AddElement<uint8_t>(XSegment::VT_ANCHORED, static_cast<uint8_t>(anchored), 0);
  }
  void add_fragments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XFragment>>> fragments) {
    fbb_.AddOffset(XSegment::VT_FRAGMENTS, fragments);
  }
  explicit XSegmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XSegment>(end);
    fbb_.Required(o, XSegment::VT_SEGMENT);
    fbb_.Required(o, XSegment::VT_FRAGMENTS);
    return o;
  }
};

inline flatbuffers::Offset<XSegment> CreateXSegment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> segment = 0,
    bool anchored = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XFragment>>> fragments = 0) {
  XSegmentBuilder builder_(_fbb);
  builder_.add_fragments(fragments);
  builder_.add_segment(segment);
  builder_.add_anchored(anchored);
  return builder_.Finish();
}

inline flatbuffers::Offset<XSegment> CreateXSegmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *segment = nullptr,
    bool anchored = false,
    const std::vector<flatbuffers::Offset<XBlueprintBlue::XFragment>> *fragments = nullptr) {
  auto segment__ = segment ? _fbb.CreateString(segment) : 0;
  auto fragments__ = fragments ? _fbb.CreateVector<flatbuffers::Offset<XBlueprintBlue::XFragment>>(*fragments) : 0;
  return XBlueprintBlue::CreateXSegment(
      _fbb,
      segment__,
      anchored,
      fragments__);
}

struct XFragment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XFragmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAGMENT = 4,
    VT_FEATURES = 6
  };
  const flatbuffers::String *fragment() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAGMENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XFeature>> *features() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XFeature>> *>(VT_FEATURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FRAGMENT) &&
           verifier.VerifyString(fragment()) &&
           VerifyOffsetRequired(verifier, VT_FEATURES) &&
           verifier.VerifyVector(features()) &&
           verifier.VerifyVectorOfTables(features()) &&
           verifier.EndTable();
  }
};

struct XFragmentBuilder {
  typedef XFragment Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fragment(flatbuffers::Offset<flatbuffers::String> fragment) {
    fbb_.AddOffset(XFragment::VT_FRAGMENT, fragment);
  }
  void add_features(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XFeature>>> features) {
    fbb_.AddOffset(XFragment::VT_FEATURES, features);
  }
  explicit XFragmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XFragment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XFragment>(end);
    fbb_.Required(o, XFragment::VT_FRAGMENT);
    fbb_.Required(o, XFragment::VT_FEATURES);
    return o;
  }
};

inline flatbuffers::Offset<XFragment> CreateXFragment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> fragment = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<XBlueprintBlue::XFeature>>> features = 0) {
  XFragmentBuilder builder_(_fbb);
  builder_.add_features(features);
  builder_.add_fragment(fragment);
  return builder_.Finish();
}

inline flatbuffers::Offset<XFragment> CreateXFragmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *fragment = nullptr,
    const std::vector<flatbuffers::Offset<XBlueprintBlue::XFeature>> *features = nullptr) {
  auto fragment__ = fragment ? _fbb.CreateString(fragment) : 0;
  auto features__ = features ? _fbb.CreateVector<flatbuffers::Offset<XBlueprintBlue::XFeature>>(*features) : 0;
  return XBlueprintBlue::CreateXFragment(
      _fbb,
      fragment__,
      features__);
}

struct XFeature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATURE = 4,
    VT_RULE = 6,
    VT_NEGATE = 8,
    VT_MATCH_TYPE = 10,
    VT_MATCH = 12
  };
  const flatbuffers::String *feature() const {
    return GetPointer<const flatbuffers::String *>(VT_FEATURE);
  }
  const flatbuffers::String *rule() const {
    return GetPointer<const flatbuffers::String *>(VT_RULE);
  }
  bool negate() const {
    return GetField<uint8_t>(VT_NEGATE, 0) != 0;
  }
  XBlueprintBlue::XCompare match_type() const {
    return static_cast<XBlueprintBlue::XCompare>(GetField<uint8_t>(VT_MATCH_TYPE, 0));
  }
  const void *match() const {
    return GetPointer<const void *>(VT_MATCH);
  }
  template<typename T> const T *match_as() const;
  const XBlueprintBlue::XWord *match_as_text() const {
    return match_type() == XBlueprintBlue::XCompare_text ? static_cast<const XBlueprintBlue::XWord *>(match()) : nullptr;
  }
  const XBlueprintBlue::XLemma *match_as_lemma() const {
    return match_type() == XBlueprintBlue::XCompare_lemma ? static_cast<const XBlueprintBlue::XLemma *>(match()) : nullptr;
  }
  const XBlueprintBlue::XPOS16 *match_as_pos16() const {
    return match_type() == XBlueprintBlue::XCompare_pos16 ? static_cast<const XBlueprintBlue::XPOS16 *>(match()) : nullptr;
  }
  const XBlueprintBlue::XPOS32 *match_as_pos32() const {
    return match_type() == XBlueprintBlue::XCompare_pos32 ? static_cast<const XBlueprintBlue::XPOS32 *>(match()) : nullptr;
  }
  const XBlueprintBlue::XPunctuation *match_as_punctuation() const {
    return match_type() == XBlueprintBlue::XCompare_punctuation ? static_cast<const XBlueprintBlue::XPunctuation *>(match()) : nullptr;
  }
  const XBlueprintBlue::XTransition *match_as_transition() const {
    return match_type() == XBlueprintBlue::XCompare_transition ? static_cast<const XBlueprintBlue::XTransition *>(match()) : nullptr;
  }
  const XBlueprintBlue::XStrongs *match_as_strongs() const {
    return match_type() == XBlueprintBlue::XCompare_strongs ? static_cast<const XBlueprintBlue::XStrongs *>(match()) : nullptr;
  }
  const XBlueprintBlue::XDelta *match_as_delta() const {
    return match_type() == XBlueprintBlue::XCompare_delta ? static_cast<const XBlueprintBlue::XDelta *>(match()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FEATURE) &&
           verifier.VerifyString(feature()) &&
           VerifyOffsetRequired(verifier, VT_RULE) &&
           verifier.VerifyString(rule()) &&
           VerifyField<uint8_t>(verifier, VT_NEGATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_MATCH) &&
           VerifyXCompare(verifier, match(), match_type()) &&
           verifier.EndTable();
  }
};

template<> inline const XBlueprintBlue::XWord *XFeature::match_as<XBlueprintBlue::XWord>() const {
  return match_as_text();
}

template<> inline const XBlueprintBlue::XLemma *XFeature::match_as<XBlueprintBlue::XLemma>() const {
  return match_as_lemma();
}

template<> inline const XBlueprintBlue::XPOS16 *XFeature::match_as<XBlueprintBlue::XPOS16>() const {
  return match_as_pos16();
}

template<> inline const XBlueprintBlue::XPOS32 *XFeature::match_as<XBlueprintBlue::XPOS32>() const {
  return match_as_pos32();
}

template<> inline const XBlueprintBlue::XPunctuation *XFeature::match_as<XBlueprintBlue::XPunctuation>() const {
  return match_as_punctuation();
}

template<> inline const XBlueprintBlue::XTransition *XFeature::match_as<XBlueprintBlue::XTransition>() const {
  return match_as_transition();
}

template<> inline const XBlueprintBlue::XStrongs *XFeature::match_as<XBlueprintBlue::XStrongs>() const {
  return match_as_strongs();
}

template<> inline const XBlueprintBlue::XDelta *XFeature::match_as<XBlueprintBlue::XDelta>() const {
  return match_as_delta();
}

struct XFeatureBuilder {
  typedef XFeature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_feature(flatbuffers::Offset<flatbuffers::String> feature) {
    fbb_.AddOffset(XFeature::VT_FEATURE, feature);
  }
  void add_rule(flatbuffers::Offset<flatbuffers::String> rule) {
    fbb_.AddOffset(XFeature::VT_RULE, rule);
  }
  void add_negate(bool negate) {
    fbb_.AddElement<uint8_t>(XFeature::VT_NEGATE, static_cast<uint8_t>(negate), 0);
  }
  void add_match_type(XBlueprintBlue::XCompare match_type) {
    fbb_.AddElement<uint8_t>(XFeature::VT_MATCH_TYPE, static_cast<uint8_t>(match_type), 0);
  }
  void add_match(flatbuffers::Offset<void> match) {
    fbb_.AddOffset(XFeature::VT_MATCH, match);
  }
  explicit XFeatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XFeature>(end);
    fbb_.Required(o, XFeature::VT_FEATURE);
    fbb_.Required(o, XFeature::VT_RULE);
    fbb_.Required(o, XFeature::VT_MATCH);
    return o;
  }
};

inline flatbuffers::Offset<XFeature> CreateXFeature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> feature = 0,
    flatbuffers::Offset<flatbuffers::String> rule = 0,
    bool negate = false,
    XBlueprintBlue::XCompare match_type = XBlueprintBlue::XCompare_NONE,
    flatbuffers::Offset<void> match = 0) {
  XFeatureBuilder builder_(_fbb);
  builder_.add_match(match);
  builder_.add_rule(rule);
  builder_.add_feature(feature);
  builder_.add_match_type(match_type);
  builder_.add_negate(negate);
  return builder_.Finish();
}

inline flatbuffers::Offset<XFeature> CreateXFeatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *feature = nullptr,
    const char *rule = nullptr,
    bool negate = false,
    XBlueprintBlue::XCompare match_type = XBlueprintBlue::XCompare_NONE,
    flatbuffers::Offset<void> match = 0) {
  auto feature__ = feature ? _fbb.CreateString(feature) : 0;
  auto rule__ = rule ? _fbb.CreateString(rule) : 0;
  return XBlueprintBlue::CreateXFeature(
      _fbb,
      feature__,
      rule__,
      negate,
      match_type,
      match);
}

struct XWord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XWordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WKEYS = 4
  };
  const flatbuffers::Vector<uint16_t> *wkeys() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_WKEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_WKEYS) &&
           verifier.VerifyVector(wkeys()) &&
           verifier.EndTable();
  }
};

struct XWordBuilder {
  typedef XWord Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wkeys(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> wkeys) {
    fbb_.AddOffset(XWord::VT_WKEYS, wkeys);
  }
  explicit XWordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XWord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XWord>(end);
    fbb_.Required(o, XWord::VT_WKEYS);
    return o;
  }
};

inline flatbuffers::Offset<XWord> CreateXWord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> wkeys = 0) {
  XWordBuilder builder_(_fbb);
  builder_.add_wkeys(wkeys);
  return builder_.Finish();
}

inline flatbuffers::Offset<XWord> CreateXWordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *wkeys = nullptr) {
  auto wkeys__ = wkeys ? _fbb.CreateVector<uint16_t>(*wkeys) : 0;
  return XBlueprintBlue::CreateXWord(
      _fbb,
      wkeys__);
}

struct XLemma FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XLemmaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEMMATA = 4
  };
  const flatbuffers::Vector<uint16_t> *lemmata() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_LEMMATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LEMMATA) &&
           verifier.VerifyVector(lemmata()) &&
           verifier.EndTable();
  }
};

struct XLemmaBuilder {
  typedef XLemma Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lemmata(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> lemmata) {
    fbb_.AddOffset(XLemma::VT_LEMMATA, lemmata);
  }
  explicit XLemmaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XLemma> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XLemma>(end);
    fbb_.Required(o, XLemma::VT_LEMMATA);
    return o;
  }
};

inline flatbuffers::Offset<XLemma> CreateXLemma(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> lemmata = 0) {
  XLemmaBuilder builder_(_fbb);
  builder_.add_lemmata(lemmata);
  return builder_.Finish();
}

inline flatbuffers::Offset<XLemma> CreateXLemmaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *lemmata = nullptr) {
  auto lemmata__ = lemmata ? _fbb.CreateVector<uint16_t>(*lemmata) : 0;
  return XBlueprintBlue::CreateXLemma(
      _fbb,
      lemmata__);
}

struct XPOS32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XPOS32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4
  };
  uint32_t pos() const {
    return GetField<uint32_t>(VT_POS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_POS, 4) &&
           verifier.EndTable();
  }
};

struct XPOS32Builder {
  typedef XPOS32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(uint32_t pos) {
    fbb_.AddElement<uint32_t>(XPOS32::VT_POS, pos, 0);
  }
  explicit XPOS32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XPOS32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XPOS32>(end);
    return o;
  }
};

inline flatbuffers::Offset<XPOS32> CreateXPOS32(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t pos = 0) {
  XPOS32Builder builder_(_fbb);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct XPOS16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XPOS16Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PNPOS = 4
  };
  uint16_t pnpos() const {
    return GetField<uint16_t>(VT_PNPOS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PNPOS, 2) &&
           verifier.EndTable();
  }
};

struct XPOS16Builder {
  typedef XPOS16 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pnpos(uint16_t pnpos) {
    fbb_.AddElement<uint16_t>(XPOS16::VT_PNPOS, pnpos, 0);
  }
  explicit XPOS16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XPOS16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XPOS16>(end);
    return o;
  }
};

inline flatbuffers::Offset<XPOS16> CreateXPOS16(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t pnpos = 0) {
  XPOS16Builder builder_(_fbb);
  builder_.add_pnpos(pnpos);
  return builder_.Finish();
}

struct XPunctuation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XPunctuationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITS = 4
  };
  uint8_t bits() const {
    return GetField<uint8_t>(VT_BITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BITS, 1) &&
           verifier.EndTable();
  }
};

struct XPunctuationBuilder {
  typedef XPunctuation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bits(uint8_t bits) {
    fbb_.AddElement<uint8_t>(XPunctuation::VT_BITS, bits, 0);
  }
  explicit XPunctuationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XPunctuation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XPunctuation>(end);
    return o;
  }
};

inline flatbuffers::Offset<XPunctuation> CreateXPunctuation(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t bits = 0) {
  XPunctuationBuilder builder_(_fbb);
  builder_.add_bits(bits);
  return builder_.Finish();
}

struct XTransition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XTransitionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITS = 4
  };
  uint8_t bits() const {
    return GetField<uint8_t>(VT_BITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BITS, 1) &&
           verifier.EndTable();
  }
};

struct XTransitionBuilder {
  typedef XTransition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bits(uint8_t bits) {
    fbb_.AddElement<uint8_t>(XTransition::VT_BITS, bits, 0);
  }
  explicit XTransitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XTransition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XTransition>(end);
    return o;
  }
};

inline flatbuffers::Offset<XTransition> CreateXTransition(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t bits = 0) {
  XTransitionBuilder builder_(_fbb);
  builder_.add_bits(bits);
  return builder_.Finish();
}

struct XStrongs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XStrongsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANG = 4,
    VT_NUMBER = 6
  };
  XBlueprintBlue::XLangEnum lang() const {
    return static_cast<XBlueprintBlue::XLangEnum>(GetField<int8_t>(VT_LANG, 0));
  }
  uint16_t number() const {
    return GetField<uint16_t>(VT_NUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LANG, 1) &&
           VerifyField<uint16_t>(verifier, VT_NUMBER, 2) &&
           verifier.EndTable();
  }
};

struct XStrongsBuilder {
  typedef XStrongs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lang(XBlueprintBlue::XLangEnum lang) {
    fbb_.AddElement<int8_t>(XStrongs::VT_LANG, static_cast<int8_t>(lang), 0);
  }
  void add_number(uint16_t number) {
    fbb_.AddElement<uint16_t>(XStrongs::VT_NUMBER, number, 0);
  }
  explicit XStrongsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XStrongs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XStrongs>(end);
    return o;
  }
};

inline flatbuffers::Offset<XStrongs> CreateXStrongs(
    flatbuffers::FlatBufferBuilder &_fbb,
    XBlueprintBlue::XLangEnum lang = XBlueprintBlue::XLangEnum_X,
    uint16_t number = 0) {
  XStrongsBuilder builder_(_fbb);
  builder_.add_number(number);
  builder_.add_lang(lang);
  return builder_.Finish();
}

struct XDelta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XDeltaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIFFERS = 4
  };
  bool differs() const {
    return GetField<uint8_t>(VT_DIFFERS, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DIFFERS, 1) &&
           verifier.EndTable();
  }
};

struct XDeltaBuilder {
  typedef XDelta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_differs(bool differs) {
    fbb_.AddElement<uint8_t>(XDelta::VT_DIFFERS, static_cast<uint8_t>(differs), 1);
  }
  explicit XDeltaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XDelta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XDelta>(end);
    return o;
  }
};

inline flatbuffers::Offset<XDelta> CreateXDelta(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool differs = true) {
  XDeltaBuilder builder_(_fbb);
  builder_.add_differs(differs);
  return builder_.Finish();
}

struct XSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXACT = 4,
    VT_SPAN = 6,
    VT_LEXICON = 8,
    VT_FORMAT = 10
  };
  bool exact() const {
    return GetField<uint8_t>(VT_EXACT, 0) != 0;
  }
  uint16_t span() const {
    return GetField<uint16_t>(VT_SPAN, 0);
  }
  XBlueprintBlue::XLexEnum lexicon() const {
    return static_cast<XBlueprintBlue::XLexEnum>(GetField<int8_t>(VT_LEXICON, 0));
  }
  XBlueprintBlue::XFmtEnum format() const {
    return static_cast<XBlueprintBlue::XFmtEnum>(GetField<int8_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXACT, 1) &&
           VerifyField<uint16_t>(verifier, VT_SPAN, 2) &&
           VerifyField<int8_t>(verifier, VT_LEXICON, 1) &&
           VerifyField<int8_t>(verifier, VT_FORMAT, 1) &&
           verifier.EndTable();
  }
};

struct XSettingsBuilder {
  typedef XSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exact(bool exact) {
    fbb_.AddElement<uint8_t>(XSettings::VT_EXACT, static_cast<uint8_t>(exact), 0);
  }
  void add_span(uint16_t span) {
    fbb_.AddElement<uint16_t>(XSettings::VT_SPAN, span, 0);
  }
  void add_lexicon(XBlueprintBlue::XLexEnum lexicon) {
    fbb_.AddElement<int8_t>(XSettings::VT_LEXICON, static_cast<int8_t>(lexicon), 0);
  }
  void add_format(XBlueprintBlue::XFmtEnum format) {
    fbb_.AddElement<int8_t>(XSettings::VT_FORMAT, static_cast<int8_t>(format), 0);
  }
  explicit XSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<XSettings> CreateXSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool exact = false,
    uint16_t span = 0,
    XBlueprintBlue::XLexEnum lexicon = XBlueprintBlue::XLexEnum_AV,
    XBlueprintBlue::XFmtEnum format = XBlueprintBlue::XFmtEnum_JSON) {
  XSettingsBuilder builder_(_fbb);
  builder_.add_span(span);
  builder_.add_format(format);
  builder_.add_lexicon(lexicon);
  builder_.add_exact(exact);
  return builder_.Finish();
}

struct XScope FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XScopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOOK = 4,
    VT_CHAPTER = 6,
    VT_VERSE = 8,
    VT_VCOUNT = 10
  };
  uint8_t book() const {
    return GetField<uint8_t>(VT_BOOK, 0);
  }
  uint8_t chapter() const {
    return GetField<uint8_t>(VT_CHAPTER, 0);
  }
  uint8_t verse() const {
    return GetField<uint8_t>(VT_VERSE, 1);
  }
  uint8_t vcount() const {
    return GetField<uint8_t>(VT_VCOUNT, 255);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BOOK, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHAPTER, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSE, 1) &&
           VerifyField<uint8_t>(verifier, VT_VCOUNT, 1) &&
           verifier.EndTable();
  }
};

struct XScopeBuilder {
  typedef XScope Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_book(uint8_t book) {
    fbb_.AddElement<uint8_t>(XScope::VT_BOOK, book, 0);
  }
  void add_chapter(uint8_t chapter) {
    fbb_.AddElement<uint8_t>(XScope::VT_CHAPTER, chapter, 0);
  }
  void add_verse(uint8_t verse) {
    fbb_.AddElement<uint8_t>(XScope::VT_VERSE, verse, 1);
  }
  void add_vcount(uint8_t vcount) {
    fbb_.AddElement<uint8_t>(XScope::VT_VCOUNT, vcount, 255);
  }
  explicit XScopeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XScope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XScope>(end);
    return o;
  }
};

inline flatbuffers::Offset<XScope> CreateXScope(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t book = 0,
    uint8_t chapter = 0,
    uint8_t verse = 1,
    uint8_t vcount = 255) {
  XScopeBuilder builder_(_fbb);
  builder_.add_vcount(vcount);
  builder_.add_verse(verse);
  builder_.add_chapter(chapter);
  builder_.add_book(book);
  return builder_.Finish();
}

inline bool VerifyXCompare(flatbuffers::Verifier &verifier, const void *obj, XCompare type) {
  switch (type) {
    case XCompare_NONE: {
      return true;
    }
    case XCompare_text: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XWord *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_lemma: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XLemma *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_pos16: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XPOS16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_pos32: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XPOS32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_punctuation: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XPunctuation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_transition: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XTransition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_strongs: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XStrongs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_delta: {
      auto ptr = reinterpret_cast<const XBlueprintBlue::XDelta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyXCompareVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyXCompare(
        verifier,  values->Get(i), types->GetEnum<XCompare>(i))) {
      return false;
    }
  }
  return true;
}

inline const XBlueprintBlue::XBlueprint *GetXBlueprint(const void *buf) {
  return flatbuffers::GetRoot<XBlueprintBlue::XBlueprint>(buf);
}

inline const XBlueprintBlue::XBlueprint *GetSizePrefixedXBlueprint(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<XBlueprintBlue::XBlueprint>(buf);
}

inline bool VerifyXBlueprintBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<XBlueprintBlue::XBlueprint>(nullptr);
}

inline bool VerifySizePrefixedXBlueprintBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<XBlueprintBlue::XBlueprint>(nullptr);
}

inline void FinishXBlueprintBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<XBlueprintBlue::XBlueprint> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedXBlueprintBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<XBlueprintBlue::XBlueprint> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace XBlueprintBlue

#endif  // FLATBUFFERS_GENERATED_BLUEPRINTBLUE_XBLUEPRINTBLUE_H_
