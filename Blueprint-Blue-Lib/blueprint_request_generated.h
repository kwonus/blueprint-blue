// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BLUEPRINTREQUEST_BLUEPRINT_REQUEST_H_
#define FLATBUFFERS_GENERATED_BLUEPRINTREQUEST_BLUEPRINT_REQUEST_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the includedf flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
//static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
//              FLATBUFFERS_VERSION_MINOR == 10 &&
//              FLATBUFFERS_VERSION_REVISION == 26,
//             "Non-compatible flatbuffers version included");

namespace Blueprint {
namespace Request {

struct XRequest;
struct XRequestBuilder;

struct XSearch;
struct XSearchBuilder;

struct XSegment;
struct XSegmentBuilder;

struct XFragment;
struct XFragmentBuilder;

struct XFeature;
struct XFeatureBuilder;

struct XWord;
struct XWordBuilder;

struct XLemma;
struct XLemmaBuilder;

struct XPOS32;
struct XPOS32Builder;

struct XPOS16;
struct XPOS16Builder;

struct XPunctuation;
struct XPunctuationBuilder;

struct XTransition;
struct XTransitionBuilder;

struct XStrongs;
struct XStrongsBuilder;

struct XDelta;
struct XDeltaBuilder;

struct XSettings;
struct XSettingsBuilder;

struct XScope;
struct XScopeBuilder;

enum XLexEnum : int8_t {
  XLexEnum_AV = 0,
  XLexEnum_AVX = 1,
  XLexEnum_MIN = XLexEnum_AV,
  XLexEnum_MAX = XLexEnum_AVX
};

inline const XLexEnum (&EnumValuesXLexEnum())[2] {
  static const XLexEnum values[] = {
    XLexEnum_AV,
    XLexEnum_AVX
  };
  return values;
}

inline const char * const *EnumNamesXLexEnum() {
  static const char * const names[3] = {
    "AV",
    "AVX",
    nullptr
  };
  return names;
}

inline const char *EnumNameXLexEnum(XLexEnum e) {
  if (flatbuffers::IsOutRange(e, XLexEnum_AV, XLexEnum_AVX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXLexEnum()[index];
}

enum XFmtEnum : int8_t {
  XFmtEnum_JSON = 0,
  XFmtEnum_TEXT = 1,
  XFmtEnum_HTML = 2,
  XFmtEnum_MD = 3,
  XFmtEnum_MIN = XFmtEnum_JSON,
  XFmtEnum_MAX = XFmtEnum_MD
};

inline const XFmtEnum (&EnumValuesXFmtEnum())[4] {
  static const XFmtEnum values[] = {
    XFmtEnum_JSON,
    XFmtEnum_TEXT,
    XFmtEnum_HTML,
    XFmtEnum_MD
  };
  return values;
}

inline const char * const *EnumNamesXFmtEnum() {
  static const char * const names[5] = {
    "JSON",
    "TEXT",
    "HTML",
    "MD",
    nullptr
  };
  return names;
}

inline const char *EnumNameXFmtEnum(XFmtEnum e) {
  if (flatbuffers::IsOutRange(e, XFmtEnum_JSON, XFmtEnum_MD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXFmtEnum()[index];
}

enum XLangEnum : int8_t {
  XLangEnum_X = 0,
  XLangEnum_H = 1,
  XLangEnum_G = 2,
  XLangEnum_MIN = XLangEnum_X,
  XLangEnum_MAX = XLangEnum_G
};

inline const XLangEnum (&EnumValuesXLangEnum())[3] {
  static const XLangEnum values[] = {
    XLangEnum_X,
    XLangEnum_H,
    XLangEnum_G
  };
  return values;
}

inline const char * const *EnumNamesXLangEnum() {
  static const char * const names[4] = {
    "X",
    "H",
    "G",
    nullptr
  };
  return names;
}

inline const char *EnumNameXLangEnum(XLangEnum e) {
  if (flatbuffers::IsOutRange(e, XLangEnum_X, XLangEnum_G)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXLangEnum()[index];
}

enum XCompare : uint8_t {
  XCompare_NONE = 0,
  XCompare_text = 1,
  XCompare_lemma = 2,
  XCompare_pos16 = 3,
  XCompare_pos32 = 4,
  XCompare_punctuation = 5,
  XCompare_transition = 6,
  XCompare_strongs = 7,
  XCompare_delta = 8,
  XCompare_MIN = XCompare_NONE,
  XCompare_MAX = XCompare_delta
};

inline const XCompare (&EnumValuesXCompare())[9] {
  static const XCompare values[] = {
    XCompare_NONE,
    XCompare_text,
    XCompare_lemma,
    XCompare_pos16,
    XCompare_pos32,
    XCompare_punctuation,
    XCompare_transition,
    XCompare_strongs,
    XCompare_delta
  };
  return values;
}

inline const char * const *EnumNamesXCompare() {
  static const char * const names[10] = {
    "NONE",
    "text",
    "lemma",
    "pos16",
    "pos32",
    "punctuation",
    "transition",
    "strongs",
    "delta",
    nullptr
  };
  return names;
}

inline const char *EnumNameXCompare(XCompare e) {
  if (flatbuffers::IsOutRange(e, XCompare_NONE, XCompare_delta)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesXCompare()[index];
}

template<typename T> struct XCompareTraits {
  static const XCompare enum_value = XCompare_NONE;
};

template<> struct XCompareTraits<Blueprint::Request::XWord> {
  static const XCompare enum_value = XCompare_text;
};

template<> struct XCompareTraits<Blueprint::Request::XLemma> {
  static const XCompare enum_value = XCompare_lemma;
};

template<> struct XCompareTraits<Blueprint::Request::XPOS16> {
  static const XCompare enum_value = XCompare_pos16;
};

template<> struct XCompareTraits<Blueprint::Request::XPOS32> {
  static const XCompare enum_value = XCompare_pos32;
};

template<> struct XCompareTraits<Blueprint::Request::XPunctuation> {
  static const XCompare enum_value = XCompare_punctuation;
};

template<> struct XCompareTraits<Blueprint::Request::XTransition> {
  static const XCompare enum_value = XCompare_transition;
};

template<> struct XCompareTraits<Blueprint::Request::XStrongs> {
  static const XCompare enum_value = XCompare_strongs;
};

template<> struct XCompareTraits<Blueprint::Request::XDelta> {
  static const XCompare enum_value = XCompare_delta;
};

bool VerifyXCompare(flatbuffers::Verifier &verifier, const void *obj, XCompare type);
bool VerifyXCompareVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct XRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETTINGS = 4,
    VT_SEARCH = 6,
    VT_SCOPE = 8,
    VT_RENDER = 10
  };
  const Blueprint::Request::XSettings *settings() const {
    return GetPointer<const Blueprint::Request::XSettings *>(VT_SETTINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XSearch>> *search() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XSearch>> *>(VT_SEARCH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XScope>> *scope() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XScope>> *>(VT_SCOPE);
  }
  bool render() const {
    return GetField<uint8_t>(VT_RENDER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SETTINGS) &&
           verifier.VerifyTable(settings()) &&
           VerifyOffset(verifier, VT_SEARCH) &&
           verifier.VerifyVector(search()) &&
           verifier.VerifyVectorOfTables(search()) &&
           VerifyOffset(verifier, VT_SCOPE) &&
           verifier.VerifyVector(scope()) &&
           verifier.VerifyVectorOfTables(scope()) &&
           VerifyField<uint8_t>(verifier, VT_RENDER, 1) &&
           verifier.EndTable();
  }
};

struct XRequestBuilder {
  typedef XRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_settings(flatbuffers::Offset<Blueprint::Request::XSettings> settings) {
    fbb_.AddOffset(XRequest::VT_SETTINGS, settings);
  }
  void add_search(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XSearch>>> search) {
    fbb_.AddOffset(XRequest::VT_SEARCH, search);
  }
  void add_scope(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XScope>>> scope) {
    fbb_.AddOffset(XRequest::VT_SCOPE, scope);
  }
  void add_render(bool render) {
    fbb_.AddElement<uint8_t>(XRequest::VT_RENDER, static_cast<uint8_t>(render), 0);
  }
  explicit XRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XRequest>(end);
    fbb_.Required(o, XRequest::VT_SETTINGS);
    return o;
  }
};

inline flatbuffers::Offset<XRequest> CreateXRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Blueprint::Request::XSettings> settings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XSearch>>> search = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XScope>>> scope = 0,
    bool render = false) {
  XRequestBuilder builder_(_fbb);
  builder_.add_scope(scope);
  builder_.add_search(search);
  builder_.add_settings(settings);
  builder_.add_render(render);
  return builder_.Finish();
}

inline flatbuffers::Offset<XRequest> CreateXRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Blueprint::Request::XSettings> settings = 0,
    const std::vector<flatbuffers::Offset<Blueprint::Request::XSearch>> *search = nullptr,
    const std::vector<flatbuffers::Offset<Blueprint::Request::XScope>> *scope = nullptr,
    bool render = false) {
  auto search__ = search ? _fbb.CreateVector<flatbuffers::Offset<Blueprint::Request::XSearch>>(*search) : 0;
  auto scope__ = scope ? _fbb.CreateVector<flatbuffers::Offset<Blueprint::Request::XScope>>(*scope) : 0;
  return Blueprint::Request::CreateXRequest(
      _fbb,
      settings,
      search__,
      scope__,
      render);
}

struct XSearch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XSearchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEARCH = 4,
    VT_NEGATE = 6,
    VT_QUOTED = 8,
    VT_SEGMENTS = 10
  };
  const flatbuffers::String *search() const {
    return GetPointer<const flatbuffers::String *>(VT_SEARCH);
  }
  bool negate() const {
    return GetField<uint8_t>(VT_NEGATE, 0) != 0;
  }
  bool quoted() const {
    return GetField<uint8_t>(VT_QUOTED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XSegment>> *segments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XSegment>> *>(VT_SEGMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SEARCH) &&
           verifier.VerifyString(search()) &&
           VerifyField<uint8_t>(verifier, VT_NEGATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_QUOTED, 1) &&
           VerifyOffsetRequired(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(segments()) &&
           verifier.VerifyVectorOfTables(segments()) &&
           verifier.EndTable();
  }
};

struct XSearchBuilder {
  typedef XSearch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_search(flatbuffers::Offset<flatbuffers::String> search) {
    fbb_.AddOffset(XSearch::VT_SEARCH, search);
  }
  void add_negate(bool negate) {
    fbb_.AddElement<uint8_t>(XSearch::VT_NEGATE, static_cast<uint8_t>(negate), 0);
  }
  void add_quoted(bool quoted) {
    fbb_.AddElement<uint8_t>(XSearch::VT_QUOTED, static_cast<uint8_t>(quoted), 0);
  }
  void add_segments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XSegment>>> segments) {
    fbb_.AddOffset(XSearch::VT_SEGMENTS, segments);
  }
  explicit XSearchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XSearch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XSearch>(end);
    fbb_.Required(o, XSearch::VT_SEARCH);
    fbb_.Required(o, XSearch::VT_SEGMENTS);
    return o;
  }
};

inline flatbuffers::Offset<XSearch> CreateXSearch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> search = 0,
    bool negate = false,
    bool quoted = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XSegment>>> segments = 0) {
  XSearchBuilder builder_(_fbb);
  builder_.add_segments(segments);
  builder_.add_search(search);
  builder_.add_quoted(quoted);
  builder_.add_negate(negate);
  return builder_.Finish();
}

inline flatbuffers::Offset<XSearch> CreateXSearchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *search = nullptr,
    bool negate = false,
    bool quoted = false,
    const std::vector<flatbuffers::Offset<Blueprint::Request::XSegment>> *segments = nullptr) {
  auto search__ = search ? _fbb.CreateString(search) : 0;
  auto segments__ = segments ? _fbb.CreateVector<flatbuffers::Offset<Blueprint::Request::XSegment>>(*segments) : 0;
  return Blueprint::Request::CreateXSearch(
      _fbb,
      search__,
      negate,
      quoted,
      segments__);
}

struct XSegment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENT = 4,
    VT_ANCHORED = 6,
    VT_FRAGMENTS = 8
  };
  const flatbuffers::String *segment() const {
    return GetPointer<const flatbuffers::String *>(VT_SEGMENT);
  }
  bool anchored() const {
    return GetField<uint8_t>(VT_ANCHORED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XFragment>> *fragments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XFragment>> *>(VT_FRAGMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SEGMENT) &&
           verifier.VerifyString(segment()) &&
           VerifyField<uint8_t>(verifier, VT_ANCHORED, 1) &&
           VerifyOffsetRequired(verifier, VT_FRAGMENTS) &&
           verifier.VerifyVector(fragments()) &&
           verifier.VerifyVectorOfTables(fragments()) &&
           verifier.EndTable();
  }
};

struct XSegmentBuilder {
  typedef XSegment Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_segment(flatbuffers::Offset<flatbuffers::String> segment) {
    fbb_.AddOffset(XSegment::VT_SEGMENT, segment);
  }
  void add_anchored(bool anchored) {
    fbb_.AddElement<uint8_t>(XSegment::VT_ANCHORED, static_cast<uint8_t>(anchored), 0);
  }
  void add_fragments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XFragment>>> fragments) {
    fbb_.AddOffset(XSegment::VT_FRAGMENTS, fragments);
  }
  explicit XSegmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XSegment>(end);
    fbb_.Required(o, XSegment::VT_SEGMENT);
    fbb_.Required(o, XSegment::VT_FRAGMENTS);
    return o;
  }
};

inline flatbuffers::Offset<XSegment> CreateXSegment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> segment = 0,
    bool anchored = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XFragment>>> fragments = 0) {
  XSegmentBuilder builder_(_fbb);
  builder_.add_fragments(fragments);
  builder_.add_segment(segment);
  builder_.add_anchored(anchored);
  return builder_.Finish();
}

inline flatbuffers::Offset<XSegment> CreateXSegmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *segment = nullptr,
    bool anchored = false,
    const std::vector<flatbuffers::Offset<Blueprint::Request::XFragment>> *fragments = nullptr) {
  auto segment__ = segment ? _fbb.CreateString(segment) : 0;
  auto fragments__ = fragments ? _fbb.CreateVector<flatbuffers::Offset<Blueprint::Request::XFragment>>(*fragments) : 0;
  return Blueprint::Request::CreateXSegment(
      _fbb,
      segment__,
      anchored,
      fragments__);
}

struct XFragment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XFragmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAGMENT = 4,
    VT_FEATURES = 6
  };
  const flatbuffers::String *fragment() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAGMENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XFeature>> *features() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XFeature>> *>(VT_FEATURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FRAGMENT) &&
           verifier.VerifyString(fragment()) &&
           VerifyOffsetRequired(verifier, VT_FEATURES) &&
           verifier.VerifyVector(features()) &&
           verifier.VerifyVectorOfTables(features()) &&
           verifier.EndTable();
  }
};

struct XFragmentBuilder {
  typedef XFragment Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fragment(flatbuffers::Offset<flatbuffers::String> fragment) {
    fbb_.AddOffset(XFragment::VT_FRAGMENT, fragment);
  }
  void add_features(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XFeature>>> features) {
    fbb_.AddOffset(XFragment::VT_FEATURES, features);
  }
  explicit XFragmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XFragment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XFragment>(end);
    fbb_.Required(o, XFragment::VT_FRAGMENT);
    fbb_.Required(o, XFragment::VT_FEATURES);
    return o;
  }
};

inline flatbuffers::Offset<XFragment> CreateXFragment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> fragment = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blueprint::Request::XFeature>>> features = 0) {
  XFragmentBuilder builder_(_fbb);
  builder_.add_features(features);
  builder_.add_fragment(fragment);
  return builder_.Finish();
}

inline flatbuffers::Offset<XFragment> CreateXFragmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *fragment = nullptr,
    const std::vector<flatbuffers::Offset<Blueprint::Request::XFeature>> *features = nullptr) {
  auto fragment__ = fragment ? _fbb.CreateString(fragment) : 0;
  auto features__ = features ? _fbb.CreateVector<flatbuffers::Offset<Blueprint::Request::XFeature>>(*features) : 0;
  return Blueprint::Request::CreateXFragment(
      _fbb,
      fragment__,
      features__);
}

struct XFeature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATURE = 4,
    VT_RULE = 6,
    VT_NEGATE = 8,
    VT_MATCH_TYPE = 10,
    VT_MATCH = 12
  };
  const flatbuffers::String *feature() const {
    return GetPointer<const flatbuffers::String *>(VT_FEATURE);
  }
  const flatbuffers::String *rule() const {
    return GetPointer<const flatbuffers::String *>(VT_RULE);
  }
  bool negate() const {
    return GetField<uint8_t>(VT_NEGATE, 0) != 0;
  }
  Blueprint::Request::XCompare match_type() const {
    return static_cast<Blueprint::Request::XCompare>(GetField<uint8_t>(VT_MATCH_TYPE, 0));
  }
  const void *match() const {
    return GetPointer<const void *>(VT_MATCH);
  }
  template<typename T> const T *match_as() const;
  const Blueprint::Request::XWord *match_as_text() const {
    return match_type() == Blueprint::Request::XCompare_text ? static_cast<const Blueprint::Request::XWord *>(match()) : nullptr;
  }
  const Blueprint::Request::XLemma *match_as_lemma() const {
    return match_type() == Blueprint::Request::XCompare_lemma ? static_cast<const Blueprint::Request::XLemma *>(match()) : nullptr;
  }
  const Blueprint::Request::XPOS16 *match_as_pos16() const {
    return match_type() == Blueprint::Request::XCompare_pos16 ? static_cast<const Blueprint::Request::XPOS16 *>(match()) : nullptr;
  }
  const Blueprint::Request::XPOS32 *match_as_pos32() const {
    return match_type() == Blueprint::Request::XCompare_pos32 ? static_cast<const Blueprint::Request::XPOS32 *>(match()) : nullptr;
  }
  const Blueprint::Request::XPunctuation *match_as_punctuation() const {
    return match_type() == Blueprint::Request::XCompare_punctuation ? static_cast<const Blueprint::Request::XPunctuation *>(match()) : nullptr;
  }
  const Blueprint::Request::XTransition *match_as_transition() const {
    return match_type() == Blueprint::Request::XCompare_transition ? static_cast<const Blueprint::Request::XTransition *>(match()) : nullptr;
  }
  const Blueprint::Request::XStrongs *match_as_strongs() const {
    return match_type() == Blueprint::Request::XCompare_strongs ? static_cast<const Blueprint::Request::XStrongs *>(match()) : nullptr;
  }
  const Blueprint::Request::XDelta *match_as_delta() const {
    return match_type() == Blueprint::Request::XCompare_delta ? static_cast<const Blueprint::Request::XDelta *>(match()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FEATURE) &&
           verifier.VerifyString(feature()) &&
           VerifyOffsetRequired(verifier, VT_RULE) &&
           verifier.VerifyString(rule()) &&
           VerifyField<uint8_t>(verifier, VT_NEGATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_MATCH) &&
           VerifyXCompare(verifier, match(), match_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Blueprint::Request::XWord *XFeature::match_as<Blueprint::Request::XWord>() const {
  return match_as_text();
}

template<> inline const Blueprint::Request::XLemma *XFeature::match_as<Blueprint::Request::XLemma>() const {
  return match_as_lemma();
}

template<> inline const Blueprint::Request::XPOS16 *XFeature::match_as<Blueprint::Request::XPOS16>() const {
  return match_as_pos16();
}

template<> inline const Blueprint::Request::XPOS32 *XFeature::match_as<Blueprint::Request::XPOS32>() const {
  return match_as_pos32();
}

template<> inline const Blueprint::Request::XPunctuation *XFeature::match_as<Blueprint::Request::XPunctuation>() const {
  return match_as_punctuation();
}

template<> inline const Blueprint::Request::XTransition *XFeature::match_as<Blueprint::Request::XTransition>() const {
  return match_as_transition();
}

template<> inline const Blueprint::Request::XStrongs *XFeature::match_as<Blueprint::Request::XStrongs>() const {
  return match_as_strongs();
}

template<> inline const Blueprint::Request::XDelta *XFeature::match_as<Blueprint::Request::XDelta>() const {
  return match_as_delta();
}

struct XFeatureBuilder {
  typedef XFeature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_feature(flatbuffers::Offset<flatbuffers::String> feature) {
    fbb_.AddOffset(XFeature::VT_FEATURE, feature);
  }
  void add_rule(flatbuffers::Offset<flatbuffers::String> rule) {
    fbb_.AddOffset(XFeature::VT_RULE, rule);
  }
  void add_negate(bool negate) {
    fbb_.AddElement<uint8_t>(XFeature::VT_NEGATE, static_cast<uint8_t>(negate), 0);
  }
  void add_match_type(Blueprint::Request::XCompare match_type) {
    fbb_.AddElement<uint8_t>(XFeature::VT_MATCH_TYPE, static_cast<uint8_t>(match_type), 0);
  }
  void add_match(flatbuffers::Offset<void> match) {
    fbb_.AddOffset(XFeature::VT_MATCH, match);
  }
  explicit XFeatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XFeature>(end);
    fbb_.Required(o, XFeature::VT_FEATURE);
    fbb_.Required(o, XFeature::VT_RULE);
    fbb_.Required(o, XFeature::VT_MATCH);
    return o;
  }
};

inline flatbuffers::Offset<XFeature> CreateXFeature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> feature = 0,
    flatbuffers::Offset<flatbuffers::String> rule = 0,
    bool negate = false,
    Blueprint::Request::XCompare match_type = Blueprint::Request::XCompare_NONE,
    flatbuffers::Offset<void> match = 0) {
  XFeatureBuilder builder_(_fbb);
  builder_.add_match(match);
  builder_.add_rule(rule);
  builder_.add_feature(feature);
  builder_.add_match_type(match_type);
  builder_.add_negate(negate);
  return builder_.Finish();
}

inline flatbuffers::Offset<XFeature> CreateXFeatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *feature = nullptr,
    const char *rule = nullptr,
    bool negate = false,
    Blueprint::Request::XCompare match_type = Blueprint::Request::XCompare_NONE,
    flatbuffers::Offset<void> match = 0) {
  auto feature__ = feature ? _fbb.CreateString(feature) : 0;
  auto rule__ = rule ? _fbb.CreateString(rule) : 0;
  return Blueprint::Request::CreateXFeature(
      _fbb,
      feature__,
      rule__,
      negate,
      match_type,
      match);
}

struct XWord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XWordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WKEYS = 4
  };
  const flatbuffers::Vector<uint16_t> *wkeys() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_WKEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_WKEYS) &&
           verifier.VerifyVector(wkeys()) &&
           verifier.EndTable();
  }
};

struct XWordBuilder {
  typedef XWord Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wkeys(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> wkeys) {
    fbb_.AddOffset(XWord::VT_WKEYS, wkeys);
  }
  explicit XWordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XWord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XWord>(end);
    fbb_.Required(o, XWord::VT_WKEYS);
    return o;
  }
};

inline flatbuffers::Offset<XWord> CreateXWord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> wkeys = 0) {
  XWordBuilder builder_(_fbb);
  builder_.add_wkeys(wkeys);
  return builder_.Finish();
}

inline flatbuffers::Offset<XWord> CreateXWordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *wkeys = nullptr) {
  auto wkeys__ = wkeys ? _fbb.CreateVector<uint16_t>(*wkeys) : 0;
  return Blueprint::Request::CreateXWord(
      _fbb,
      wkeys__);
}

struct XLemma FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XLemmaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEMMATA = 4
  };
  const flatbuffers::Vector<uint16_t> *lemmata() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_LEMMATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LEMMATA) &&
           verifier.VerifyVector(lemmata()) &&
           verifier.EndTable();
  }
};

struct XLemmaBuilder {
  typedef XLemma Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lemmata(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> lemmata) {
    fbb_.AddOffset(XLemma::VT_LEMMATA, lemmata);
  }
  explicit XLemmaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XLemma> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XLemma>(end);
    fbb_.Required(o, XLemma::VT_LEMMATA);
    return o;
  }
};

inline flatbuffers::Offset<XLemma> CreateXLemma(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> lemmata = 0) {
  XLemmaBuilder builder_(_fbb);
  builder_.add_lemmata(lemmata);
  return builder_.Finish();
}

inline flatbuffers::Offset<XLemma> CreateXLemmaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *lemmata = nullptr) {
  auto lemmata__ = lemmata ? _fbb.CreateVector<uint16_t>(*lemmata) : 0;
  return Blueprint::Request::CreateXLemma(
      _fbb,
      lemmata__);
}

struct XPOS32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XPOS32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4
  };
  uint32_t pos() const {
    return GetField<uint32_t>(VT_POS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_POS, 4) &&
           verifier.EndTable();
  }
};

struct XPOS32Builder {
  typedef XPOS32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(uint32_t pos) {
    fbb_.AddElement<uint32_t>(XPOS32::VT_POS, pos, 0);
  }
  explicit XPOS32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XPOS32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XPOS32>(end);
    return o;
  }
};

inline flatbuffers::Offset<XPOS32> CreateXPOS32(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t pos = 0) {
  XPOS32Builder builder_(_fbb);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct XPOS16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XPOS16Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PNPOS = 4
  };
  uint16_t pnpos() const {
    return GetField<uint16_t>(VT_PNPOS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PNPOS, 2) &&
           verifier.EndTable();
  }
};

struct XPOS16Builder {
  typedef XPOS16 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pnpos(uint16_t pnpos) {
    fbb_.AddElement<uint16_t>(XPOS16::VT_PNPOS, pnpos, 0);
  }
  explicit XPOS16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XPOS16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XPOS16>(end);
    return o;
  }
};

inline flatbuffers::Offset<XPOS16> CreateXPOS16(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t pnpos = 0) {
  XPOS16Builder builder_(_fbb);
  builder_.add_pnpos(pnpos);
  return builder_.Finish();
}

struct XPunctuation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XPunctuationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITS = 4
  };
  uint8_t bits() const {
    return GetField<uint8_t>(VT_BITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BITS, 1) &&
           verifier.EndTable();
  }
};

struct XPunctuationBuilder {
  typedef XPunctuation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bits(uint8_t bits) {
    fbb_.AddElement<uint8_t>(XPunctuation::VT_BITS, bits, 0);
  }
  explicit XPunctuationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XPunctuation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XPunctuation>(end);
    return o;
  }
};

inline flatbuffers::Offset<XPunctuation> CreateXPunctuation(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t bits = 0) {
  XPunctuationBuilder builder_(_fbb);
  builder_.add_bits(bits);
  return builder_.Finish();
}

struct XTransition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XTransitionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITS = 4
  };
  uint8_t bits() const {
    return GetField<uint8_t>(VT_BITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BITS, 1) &&
           verifier.EndTable();
  }
};

struct XTransitionBuilder {
  typedef XTransition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bits(uint8_t bits) {
    fbb_.AddElement<uint8_t>(XTransition::VT_BITS, bits, 0);
  }
  explicit XTransitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XTransition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XTransition>(end);
    return o;
  }
};

inline flatbuffers::Offset<XTransition> CreateXTransition(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t bits = 0) {
  XTransitionBuilder builder_(_fbb);
  builder_.add_bits(bits);
  return builder_.Finish();
}

struct XStrongs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XStrongsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANG = 4,
    VT_NUMBER = 6
  };
  Blueprint::Request::XLangEnum lang() const {
    return static_cast<Blueprint::Request::XLangEnum>(GetField<int8_t>(VT_LANG, 0));
  }
  uint16_t number() const {
    return GetField<uint16_t>(VT_NUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LANG, 1) &&
           VerifyField<uint16_t>(verifier, VT_NUMBER, 2) &&
           verifier.EndTable();
  }
};

struct XStrongsBuilder {
  typedef XStrongs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lang(Blueprint::Request::XLangEnum lang) {
    fbb_.AddElement<int8_t>(XStrongs::VT_LANG, static_cast<int8_t>(lang), 0);
  }
  void add_number(uint16_t number) {
    fbb_.AddElement<uint16_t>(XStrongs::VT_NUMBER, number, 0);
  }
  explicit XStrongsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XStrongs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XStrongs>(end);
    return o;
  }
};

inline flatbuffers::Offset<XStrongs> CreateXStrongs(
    flatbuffers::FlatBufferBuilder &_fbb,
    Blueprint::Request::XLangEnum lang = Blueprint::Request::XLangEnum_X,
    uint16_t number = 0) {
  XStrongsBuilder builder_(_fbb);
  builder_.add_number(number);
  builder_.add_lang(lang);
  return builder_.Finish();
}

struct XDelta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XDeltaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIFFERS = 4
  };
  bool differs() const {
    return GetField<uint8_t>(VT_DIFFERS, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DIFFERS, 1) &&
           verifier.EndTable();
  }
};

struct XDeltaBuilder {
  typedef XDelta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_differs(bool differs) {
    fbb_.AddElement<uint8_t>(XDelta::VT_DIFFERS, static_cast<uint8_t>(differs), 1);
  }
  explicit XDeltaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XDelta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XDelta>(end);
    return o;
  }
};

inline flatbuffers::Offset<XDelta> CreateXDelta(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool differs = true) {
  XDeltaBuilder builder_(_fbb);
  builder_.add_differs(differs);
  return builder_.Finish();
}

struct XSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXACT = 4,
    VT_SPAN = 6,
    VT_LEXICON = 8,
    VT_FORMAT = 10
  };
  bool exact() const {
    return GetField<uint8_t>(VT_EXACT, 0) != 0;
  }
  uint16_t span() const {
    return GetField<uint16_t>(VT_SPAN, 0);
  }
  Blueprint::Request::XLexEnum lexicon() const {
    return static_cast<Blueprint::Request::XLexEnum>(GetField<int8_t>(VT_LEXICON, 0));
  }
  Blueprint::Request::XFmtEnum format() const {
    return static_cast<Blueprint::Request::XFmtEnum>(GetField<int8_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXACT, 1) &&
           VerifyField<uint16_t>(verifier, VT_SPAN, 2) &&
           VerifyField<int8_t>(verifier, VT_LEXICON, 1) &&
           VerifyField<int8_t>(verifier, VT_FORMAT, 1) &&
           verifier.EndTable();
  }
};

struct XSettingsBuilder {
  typedef XSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exact(bool exact) {
    fbb_.AddElement<uint8_t>(XSettings::VT_EXACT, static_cast<uint8_t>(exact), 0);
  }
  void add_span(uint16_t span) {
    fbb_.AddElement<uint16_t>(XSettings::VT_SPAN, span, 0);
  }
  void add_lexicon(Blueprint::Request::XLexEnum lexicon) {
    fbb_.AddElement<int8_t>(XSettings::VT_LEXICON, static_cast<int8_t>(lexicon), 0);
  }
  void add_format(Blueprint::Request::XFmtEnum format) {
    fbb_.AddElement<int8_t>(XSettings::VT_FORMAT, static_cast<int8_t>(format), 0);
  }
  explicit XSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<XSettings> CreateXSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool exact = false,
    uint16_t span = 0,
    Blueprint::Request::XLexEnum lexicon = Blueprint::Request::XLexEnum_AV,
    Blueprint::Request::XFmtEnum format = Blueprint::Request::XFmtEnum_JSON) {
  XSettingsBuilder builder_(_fbb);
  builder_.add_span(span);
  builder_.add_format(format);
  builder_.add_lexicon(lexicon);
  builder_.add_exact(exact);
  return builder_.Finish();
}

struct XScope FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XScopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOOK = 4,
    VT_CHAPTER = 6,
    VT_VERSE = 8,
    VT_VCOUNT = 10
  };
  uint8_t book() const {
    return GetField<uint8_t>(VT_BOOK, 0);
  }
  uint8_t chapter() const {
    return GetField<uint8_t>(VT_CHAPTER, 0);
  }
  uint8_t verse() const {
    return GetField<uint8_t>(VT_VERSE, 1);
  }
  uint8_t vcount() const {
    return GetField<uint8_t>(VT_VCOUNT, 255);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BOOK, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHAPTER, 1) &&
           VerifyField<uint8_t>(verifier, VT_VERSE, 1) &&
           VerifyField<uint8_t>(verifier, VT_VCOUNT, 1) &&
           verifier.EndTable();
  }
};

struct XScopeBuilder {
  typedef XScope Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_book(uint8_t book) {
    fbb_.AddElement<uint8_t>(XScope::VT_BOOK, book, 0);
  }
  void add_chapter(uint8_t chapter) {
    fbb_.AddElement<uint8_t>(XScope::VT_CHAPTER, chapter, 0);
  }
  void add_verse(uint8_t verse) {
    fbb_.AddElement<uint8_t>(XScope::VT_VERSE, verse, 1);
  }
  void add_vcount(uint8_t vcount) {
    fbb_.AddElement<uint8_t>(XScope::VT_VCOUNT, vcount, 255);
  }
  explicit XScopeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XScope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XScope>(end);
    return o;
  }
};

inline flatbuffers::Offset<XScope> CreateXScope(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t book = 0,
    uint8_t chapter = 0,
    uint8_t verse = 1,
    uint8_t vcount = 255) {
  XScopeBuilder builder_(_fbb);
  builder_.add_vcount(vcount);
  builder_.add_verse(verse);
  builder_.add_chapter(chapter);
  builder_.add_book(book);
  return builder_.Finish();
}

inline bool VerifyXCompare(flatbuffers::Verifier &verifier, const void *obj, XCompare type) {
  switch (type) {
    case XCompare_NONE: {
      return true;
    }
    case XCompare_text: {
      auto ptr = reinterpret_cast<const Blueprint::Request::XWord *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_lemma: {
      auto ptr = reinterpret_cast<const Blueprint::Request::XLemma *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_pos16: {
      auto ptr = reinterpret_cast<const Blueprint::Request::XPOS16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_pos32: {
      auto ptr = reinterpret_cast<const Blueprint::Request::XPOS32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_punctuation: {
      auto ptr = reinterpret_cast<const Blueprint::Request::XPunctuation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_transition: {
      auto ptr = reinterpret_cast<const Blueprint::Request::XTransition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_strongs: {
      auto ptr = reinterpret_cast<const Blueprint::Request::XStrongs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case XCompare_delta: {
      auto ptr = reinterpret_cast<const Blueprint::Request::XDelta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyXCompareVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyXCompare(
        verifier,  values->Get(i), types->GetEnum<XCompare>(i))) {
      return false;
    }
  }
  return true;
}

inline const Blueprint::Request::XRequest *GetXRequest(const void *buf) {
  return flatbuffers::GetRoot<Blueprint::Request::XRequest>(buf);
}

inline const Blueprint::Request::XRequest *GetSizePrefixedXRequest(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Blueprint::Request::XRequest>(buf);
}

inline bool VerifyXRequestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Blueprint::Request::XRequest>(nullptr);
}

inline bool VerifySizePrefixedXRequestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Blueprint::Request::XRequest>(nullptr);
}

inline void FinishXRequestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Blueprint::Request::XRequest> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedXRequestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Blueprint::Request::XRequest> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Request
}  // namespace Blueprint

#endif  // FLATBUFFERS_GENERATED_BLUEPRINTREQUEST_BLUEPRINT_REQUEST_H_
