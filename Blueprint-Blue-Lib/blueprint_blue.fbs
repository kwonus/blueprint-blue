attribute "fs_serializer";
attribute "fs_rpcInterface";
attribute "fs_sharedString";

namespace XBlueprintBlue;

enum XThreshold: byte { NONE = 0, FUZZY_MIN = 33, FUZZY_MAX = 99, EXACT = 100 }
enum XOutEnum:   byte { AV = 1, AVX = 2 }
enum XLexEnum:   byte { AV = 1, AVX = 2, BOTH = 3 }
enum XFmtEnum:   byte { JSON = 0, TEXT = 1, HTML = 2, MD = 3 }
enum XLangEnum:  byte { H = 1, G = 2, X = 0 }
enum XStatusEnum:byte { OKAY = 0, ERROR = -128 }

table XBlueprint (fs_serializer) { // was: XRequest
    command:     string      (required);
    settings:    XSettings   (required);
    search:    [ XSearch ];
    scope:     [ XScope ];
    singleton:   XCommand;
    status:      XStatusEnum = ERROR;  // required
    help:        string      (required); // url of help-file for singleton.command xor search.expression  [likely on github for automatic markdown to html conversion]
    warnings:  [ string ];
    errors:    [ string ];
}

table XCommand (fs_serializer) { // for singleton expressions
    command:     string      (required);
    verb:        string      (required);
    arguments: [ string ];
    reply:       XReply;
}

table XReply (fs_serializer) {
    version:     string;      // for @version
    help:        string;      // for @help
    value:       string;      // for @get
    macro:       XStatement;  // for @expand
    history:   [ XStatement ];// for @review (history)
}

table XStatement (fs_serializer) {
    id:          uint32 = 0;  // required for @review (history)
    label:       string;      // required for @expand reply
    time:        uint64 = 0;  // required
    stmt:        string      (required);
    expd:        string      (required);
    summary:     string;      // defined only for searches
    settings:    XSettings   (required);
}

table XSearch (fs_serializer) {
    expression:  string       (required); // segment
    quoted:      bool        = false;
    fragments:  [ XFragment ] (required);
}

table XFragment (fs_serializer) {
    fragment:    string      (required);
    anchored:    bool        = false;
    required:  [ XOption ]   (required); // AND conditions (all must match)
}

table XOption (fs_serializer) {
    option:      string      (required);
    features:  [ XFeature ]  (required); // OR conditions (any can match)
}

union XCompare {
    text:        XWord,
    lemma:       XLemma,
    pos16:       XPOS16,
    pos32:       XPOS32,
    punctuation: XPunctuation,
    transition:  XTransition,
    strongs:     XStrongs,
    delta:       XDelta
}

table XFeature (fs_serializer) {
    feature:     string      (required);
    rule:        string      (required);
    negate:      bool        = false;
    match:       XCompare    (required);
}

// Most of the Blueprint-Blue flatbuffer object is generated from the Pinshot-Blue parse (Rust FFI).
// However, XWord is now generated using the NUPhone assembly (C#).
// This way, AVX-Search can perform fuzzy matches, w/o requiring a C++ implementation for English-to-IPA
// (NUPhone comparison library will be ported to C++)

table XLex (fs_serializer) {
    key:         uint16 = 0;             // zero is a valid value for OOV items (items found neither in lexicon, nor in OOV-Lemmata)
    phonetics: [ string ] (required);    // required, but may be empty (in the case of QWildcard: we do not find phonetic variants for all lexicon matches)
}

table XWord (fs_serializer) {
    lex:       [ XLex ] (required);
}

table XLemma (fs_serializer) {
    lemmata:   [ XLex ] (required);
}

table XPOS32 (fs_serializer) {
    pos:         uint32;
}

table XPOS16 (fs_serializer) {
    pnpos:       uint16;
}

table XPunctuation (fs_serializer) {
    bits:        uint8;
}

table XTransition (fs_serializer) {
    bits:        uint8;
}

table XStrongs (fs_serializer) {
    lang:        XLangEnum = X;    
    number:      uint16;
}

table XDelta (fs_serializer) {
    differs:     bool      = true; // must be explicitly set to T or F
}

table XSettings (fs_serializer) {
    similarity:  string   (required);
    span:        uint16   = 0;
    lexicon:     XLexEnum = BOTH;
    display:     XOutEnum = AV;
    format:      XFmtEnum = JSON;
}

table XScope (fs_serializer) {
    book:        uint8 = 0;      // required
    chapter:     uint8 = 0;      // required
    verse:       uint8 = 1;      // optional
    vcount:      uint8 = 255;    // optional: verse-count: defaults to all remaining verses in chapter
}

root_type XBlueprint;

//rpc_service BlueprintSVC (fs_rpcInterface)
//{
//     CreateBlueprint (QuelleRequest) : XBlueprint;
//}