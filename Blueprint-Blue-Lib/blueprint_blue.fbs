attribute "fs_serializer";
attribute "fs_rpcInterface";
attribute "fs_sharedString";

namespace XBlueprintBlue;

enum XThreshold: byte { NONE = 0, FUZZY_MIN = 33, FUZZY_MAX = 99, EXACT = 100 }
enum XOutEnum:   byte { AV = 1, AVX = 2 }
enum XLexEnum:   byte { AV = 1, AVX = 2, BOTH = 3 }
enum XFmtEnum:   byte { JSON = 0, TEXT = 1, HTML = 2, MD = 3 }
enum XLangEnum:  byte { H = 1, G = 2, X = 0 }
enum XUserEnum:  byte { ANONYMOUS = 0, EXISTING = 1, NEW = 2, RESET = 3, UNKNOWN = 4 }
enum XStatusEnum:byte { COMPLETED = 0, FEEDBACK_EXPECTED = 1, ERROR = 2, UNKNOWN = 3 }
//   When Status == COMPLETED: there is no further action required by avx-command [same is true for ERROR and UNKNOWN] // although reporting status or error to the user may still be warrented
//   When Status == ACTION_REQUIRED: the verb will not be complete until avx-command performs additional actions
//   When Status == FEEDBACK_REQUESTED: this is similar to ACTION_REQUIRED, but a return message from avx-command is also expected subsequently
//   (feedback message facillitates search summaries to be written into the command history; blueprint-blue manages all user-persisted data)

//table QuelleRequest (fs_serializer) {
//    command:     string      (required);
//    user:        XUser;  //  Eventually, this could become required for web-hosted instances of this service
//}

table XUser (fs_serializer) {
    username:    string      (required);
    disposition: XUserEnum   = ANONYMOUS;
}

table XBlueprint (fs_serializer) { // was: XRequest
    settings:    XSettings   (required);
    search:    [ XSearch ];
    scope:     [ XScope ];
    singleton:   XCommand;
    status:      XStatusEnum = UNKNOWN;  // required
    help:        string      (required); // url of help-file for singleton.command xor search.expression  [likely on github for automatic markdown to html conversion]
    warnings:  [ string ];
    errors:    [ string ];
}

table XCommand (fs_serializer) { // for singleton expressions
    command:     string      (required);
    verb:        string      (required);
    arguments: [ string ];
    reply:       XReply;
}

table XReply (fs_serializer) {
    version:     string;      // for @version
    help:        string;      // for @help
    value:       string;      // for @get
    macro:       XStatement;  // for @expand
    history:   [ XStatement ];// for @review (history)
}

table XStatement (fs_serializer) {
    id:          uint32 = 0;  // required for @review (history)
    label:       string;      // required for @expand reply
    time:        uint64 = 0;  // required
    stmt:        string      (required);
    expd:        string      (required);
    summary:     string;      // defined only for searches
    settings:    XSettings   (required);
}

table XSearch (fs_serializer) {
    expression:  string      (required);
    negate:      bool        = false;
    quoted:      bool        = false;
    segments:  [ XSegment ]  (required);
}

table XSegment (fs_serializer) {
    segment:     string      (required);
    anchored:    bool        = false;
    fragments:  [ XFragment ] (required);
}

table XFragment (fs_serializer) {
    fragment:    string      (required);
    features:  [ XFeature ]  (required);
}

union XCompare {
    text:        XWord,
    lemma:       XLemma,
    pos16:       XPOS16,
    pos32:       XPOS32,
    punctuation: XPunctuation,
    transition:  XTransition,
    strongs:     XStrongs,
    delta:       XDelta
}

table XFeature (fs_serializer) {
    feature:     string      (required);
    rule:        string      (required);
    negate:      bool        = false;
    match:       XCompare    (required);
}

table XWord (fs_serializer) {
    wkeys:     [ uint16 ] (required);
}

table XLemma (fs_serializer) {
    lemmata:   [ uint16 ] (required);
}

table XPOS32 (fs_serializer) {
    pos:         uint32;
}

table XPOS16 (fs_serializer) {
    pnpos:       uint16;
}

table XPunctuation (fs_serializer) {
    bits:        uint8;
}

table XTransition (fs_serializer) {
    bits:        uint8;
}

table XStrongs (fs_serializer) {
    lang:        XLangEnum = X;    
    number:      uint16;
}

table XDelta (fs_serializer) {
    differs:     bool      = true; // must be explicitly set to T or F
}

table XSettings (fs_serializer) {
    similarity:  byte     = 0;
    span:        uint16   = 0;
    lexicon:     XLexEnum = BOTH;
    display:     XOutEnum = AV;
    format:      XFmtEnum = JSON;
}

table XScope (fs_serializer) {
    book:        uint8 = 0;       // required
    chapter:     uint8 = 0;      // required
    verse:       uint8 = 1;      // optional
    vcount:      uint8 = 255;    // optional: verse-count: defaults to all remaining verses in chapter
}

root_type XBlueprint;

//rpc_service BlueprintSVC (fs_rpcInterface)
//{
//     CreateBlueprint (QuelleRequest) : XBlueprint;
//}